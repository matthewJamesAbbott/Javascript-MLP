<!--
   Matthew Abbott
   Multi-Layer Perceptron (MLP)

-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MLP</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            margin: 0; padding: 1.5rem;
            background: #f8fafc;
            color: #1e293b;
        }
        h1 { color: #0f172a; margin-bottom: 0.5rem; }
        h2 { color: #334155; font-size: 1.1rem; margin: 0 0 0.75rem 0; }
        .container { max-width: 1400px; margin: 0 auto; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
        .panel { 
            background: white; 
            border-radius: 12px; 
            padding: 1.25rem; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .section { margin-bottom: 1.25rem; }
        .section:last-child { margin-bottom: 0; }
        
        label { display: inline-block; margin: 0.25rem 0.5rem 0.25rem 0; font-size: 0.9rem; }
        input[type="number"], input[type="text"], select { 
            padding: 0.4rem 0.5rem; 
            border: 1px solid #cbd5e1; 
            border-radius: 6px;
            font-size: 0.9rem;
        }
        input[type="number"] { width: 4.5rem; }
        input[type="text"].nodevals { width: 5rem; }
        input.error { border-color: #ef4444; background: #fef2f2; }
        textarea { 
            width: 100%; height: 6rem; 
            padding: 0.5rem; 
            border: 1px solid #cbd5e1; 
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.85rem;
            resize: vertical;
        }
        textarea.error { border-color: #ef4444; background: #fef2f2; }
        
        input[type="checkbox"] { 
            width: 1rem; height: 1rem; 
            vertical-align: middle; 
            margin-right: 0.25rem;
        }
        
        button { 
            padding: 0.5rem 1rem; 
            background: #3b82f6; 
            color: white; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer;
            font-size: 0.9rem;
            margin: 0.25rem 0.25rem 0.25rem 0;
            transition: background 0.2s;
        }
        button:hover { background: #2563eb; }
        button:disabled { background: #94a3b8; cursor: not-allowed; }
        button.secondary { background: #64748b; }
        button.secondary:hover { background: #475569; }
        button.danger { background: #ef4444; }
        button.danger:hover { background: #dc2626; }
        
        .error-msg { 
            color: #dc2626; 
            background: #fef2f2; 
            padding: 0.5rem 0.75rem; 
            border-radius: 6px; 
            margin: 0.5rem 0;
            font-size: 0.85rem;
        }
        .success-msg {
            color: #16a34a;
            background: #f0fdf4;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            font-size: 0.85rem;
        }
        
        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .metric {
            background: #f1f5f9;
            padding: 0.75rem;
            border-radius: 8px;
            text-align: center;
        }
        .metric-label { font-size: 0.75rem; color: #64748b; text-transform: uppercase; }
        .metric-value { font-size: 1.25rem; font-weight: 600; color: #0f172a; }
        
        #lossChart { 
            width: 100%; 
            height: 200px; 
            background: #f8fafc; 
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .output-panel {
            background: #f1f5f9;
            padding: 1rem;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.85rem;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .slider-container { display: flex; align-items: center; gap: 0.5rem; margin: 0.25rem 0; }
        .slider-container input[type="range"] { flex: 1; max-width: 150px; }
        .slider-value { min-width: 3rem; font-size: 0.85rem; color: #64748b; }
        
        .input-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); 
            gap: 0.5rem;
            max-height: 150px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }
        .input-row { 
            display: flex; 
            align-items: center; 
            gap: 0.25rem;
            background: #f8fafc;
            padding: 0.4rem;
            border-radius: 6px;
        }
        .input-label { min-width: 3rem; font-size: 0.8rem; color: #64748b; }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
            margin: 0.5rem 0;
        }
        .progress-fill {
            height: 100%;
            background: #3b82f6;
            transition: width 0.1s;
        }
        
        .legend { font-size: 0.75rem; color: #64748b; margin-top: 0.5rem; }
        
        @media (max-width: 900px) {
            .grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Multi-Layer Perceptron</h1>
        <p style="color:#64748b; margin-bottom:1.5rem;">Full backpropagation with live visualization and JSON model persistence</p>
        
        <div class="grid">
            <!-- Left Column: Configuration & Inputs -->
            <div>
                <!-- Network Configuration -->
                <div class="panel section">
                    <h2>Network Configuration</h2>
                    <div style="display:flex; flex-wrap:wrap; gap:0.5rem 1rem;">
                        <label>Input Size: <input type="number" id="inputSize" value="2" min="1" max="100"></label>
                        <label>Hidden Sizes: <input type="text" id="hiddenSizes" value="4" placeholder="e.g., 4 or 4,3,2"></label>
                        <label>Output Size: <input type="number" id="outputSize" value="1" min="1" max="32"></label>
                    </div>
                    <div style="margin-top:0.75rem;">
                        <button onclick="createNetwork()">Create Network</button>
                        <button class="secondary" onclick="randomizeInputs()">Random Inputs</button>
                        <button class="danger" onclick="resetModel()">Reset</button>
                    </div>
                </div>
                
                <!-- Hyperparameters -->
                <div class="panel section">
                    <h2>Hyperparameters</h2>
                    <div class="slider-container">
                        <label>Learning Rate:</label>
                        <input type="range" id="learningRate" min="-4" max="-1" step="0.1" value="-1" oninput="updateSliderDisplay()">
                        <span class="slider-value" id="lrDisplay">0.1</span>
                    </div>
                    <div class="slider-container">
                        <label>Iterations:</label>
                        <input type="range" id="trainIters" min="10" max="1000" step="10" value="100" oninput="updateSliderDisplay()">
                        <span class="slider-value" id="iterDisplay">100</span>
                    </div>
                    <div style="margin-top:0.5rem;">
                        <label>Hidden Activation: 
                            <select id="hiddenActivation">
                                <option value="sigmoid">Sigmoid</option>
                                <option value="tanh">Tanh</option>
                                <option value="relu">ReLU</option>
                            </select>
                        </label>
                        <label>Output Activation: 
                            <select id="outputActivation">
                                <option value="sigmoid">Sigmoid</option>
                                <option value="tanh">Tanh</option>
                                <option value="relu">ReLU</option>
                            </select>
                        </label>
                    </div>
                    <div style="margin-top:0.5rem;">
                        <label>Optimizer:
                            <select id="optimizer">
                                <option value="sgd">SGD</option>
                                <option value="adam">Adam</option>
                                <option value="rmsprop">RMSProp</option>
                            </select>
                        </label>
                    </div>
                </div>

                <!-- Regularization -->
                <div class="panel section">
                    <h2>Regularization</h2>
                    <div class="slider-container">
                        <label>Dropout Rate (0-1):</label>
                        <input type="range" id="dropoutRate" min="0" max="0.9" step="0.1" value="0" oninput="updateSliderDisplay()">
                        <span class="slider-value" id="dropoutDisplay">0.0</span>
                    </div>
                    <div class="slider-container">
                        <label>L2 Lambda (0-0.1):</label>
                        <input type="range" id="l2Lambda" min="0" max="0.1" step="0.001" value="0" oninput="updateSliderDisplay()">
                        <span class="slider-value" id="l2Display">0.0</span>
                    </div>
                </div>
                
                <!-- Data Loading -->
                <div class="panel section">
                    <h2>Load Training Data</h2>
                    <input type="file" id="csvFile" accept=".csv">
                    <button onclick="loadCSV()">Load CSV File</button>
                    <span id="dataStatus" style="margin-left:1rem;"></span>
                    <div style="margin-top:0.5rem;">
                        <label>Or paste CSV data:</label>
                        <textarea id="csvPaste" rows="4" cols="40"></textarea>
                        <button onclick="loadCSVText()" style="margin-top:0.5rem;">Load Pasted CSV</button>
                    </div>
                    <div style="margin-top:0.5rem;">
                        <label><input type="checkbox" id="normalizeData" checked> Normalize input features to [0,1]</label>
                    </div>
                </div>

                <!-- Input Features -->
                <div class="panel section">
                    <h2>Input Features</h2>
                    <div id="inputFields" class="input-grid"></div>
                    <div id="inputError"></div>
                </div>
            </div>
            
            <!-- Right Column: Output & Visualization -->
            <div>
                <!-- Training & Prediction -->
                <div class="panel section">
                    <h2>Training & Prediction</h2>
                    <div>
                        <label>Target Output: <input type="text" id="targetOutput" placeholder="e.g., 0.8" value="0.5"></label>
                    </div>
                    <div style="margin-top:0.5rem;">
                        <button id="trainBtn" onclick="trainModel()" disabled>Train</button>
                        <button id="predictBtn" onclick="predictModel()" disabled>Predict</button>
                        <button class="secondary" onclick="saveModelDialog()">Save Model</button>
                        <button class="secondary" onclick="loadModelDialog()">Load Model</button>
                    </div>
                    <div id="output" class="output-panel" style="margin-top:1rem;"></div>
                </div>
                
                <!-- Loss Chart -->
                <div class="panel section">
                    <h2>Loss History</h2>
                    <canvas id="lossChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
// ==================== NEURON & LAYER ====================

class Neuron {
    constructor(numInputs) {
        this.weights = Array.from({length: numInputs}, () => Math.random() * 2 - 1);
        this.bias = Math.random() * 2 - 1;
        this.output = 0;
        this.error = 0;
        this.m = Array(numInputs).fill(0);
        this.v = Array(numInputs).fill(0);
        this.mBias = 0;
        this.vBias = 0;
    }
}

class DenseLayer {
    constructor(numNeurons, numInputs, activation = 'sigmoid') {
        this.neurons = Array.from({length: numNeurons}, () => new Neuron(numInputs));
        this.activation = activation;
        this.lastInput = [];
    }

    forward(input) {
        this.lastInput = [...input];
        return this.neurons.map(neuron => {
            const preAct = neuron.weights.reduce((s, w, i) => s + w * input[i], neuron.bias);
            neuron.output = this.applyActivation(preAct);
            return neuron.output;
        });
    }

    applyActivation(x) {
        switch(this.activation) {
            case 'sigmoid': return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
            case 'tanh': return Math.tanh(x);
            case 'relu': return Math.max(0, x);
            default: return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
        }
    }

    activationDerivative(output, preAct) {
        switch(this.activation) {
            case 'sigmoid': return output * (1 - output);
            case 'tanh': return 1 - output * output;
            case 'relu': return preAct > 0 ? 1 : 0;
            default: return output * (1 - output);
        }
    }

    setWeights(data) {
        if (data.weights && data.biases) {
            for (let i = 0; i < this.neurons.length; i++) {
                this.neurons[i].weights = [...data.weights[i]];
                this.neurons[i].bias = data.biases[i] || 0;
            }
        }
    }

    getWeights() {
        return {
            weights: this.neurons.map(n => [...n.weights]),
            biases: this.neurons.map(n => n.bias)
        };
    }
}

// ==================== MLP ====================

class MultiLayerPerceptron {
    constructor(inputSize, hiddenSizes, outputSize, hiddenAct = 'sigmoid', outputAct = 'sigmoid') {
        this.inputSize = inputSize;
        this.hiddenSizes = hiddenSizes;
        this.outputSize = outputSize;
        this.hiddenActivation = hiddenAct;
        this.outputActivation = outputAct;
        
        this.layers = [];
        
        // Build hidden layers
        let prevSize = inputSize;
        for (let size of hiddenSizes) {
            this.layers.push(new DenseLayer(size, prevSize, hiddenAct));
            prevSize = size;
        }
        
        // Output layer
        this.layers.push(new DenseLayer(outputSize, prevSize, outputAct));
        
        this.learningRate = 0.1;
        this.lossHistory = [];
    }

    forward(input) {
        let current = input;
        for (let layer of this.layers) {
            current = layer.forward(current);
        }
        return current;
    }

    predict(input) {
        return this.forward(input);
    }

    backward(target) {
        let errors = [];
        const outputLayer = this.layers[this.layers.length - 1];
        
        // Output layer error
        for (let i = 0; i < outputLayer.neurons.length; i++) {
            const neuron = outputLayer.neurons[i];
            const delta = target[i] - neuron.output;
            errors[i] = delta * neuron.outputActivateDerivative ? 
                delta * (neuron.output * (1 - neuron.output)) : 
                delta * neuron.output * (1 - neuron.output);
            neuron.error = errors[i];
        }
        
        // Backprop through hidden layers
        for (let l = this.layers.length - 2; l >= 0; l--) {
            const layer = this.layers[l];
            const nextLayer = this.layers[l + 1];
            const nextErrors = [];
            
            for (let i = 0; i < layer.neurons.length; i++) {
                let error = 0;
                for (let j = 0; j < nextLayer.neurons.length; j++) {
                    error += nextLayer.neurons[j].weights[i] * nextLayer.neurons[j].error;
                }
                const neuron = layer.neurons[i];
                nextErrors[i] = error * (neuron.output * (1 - neuron.output));
                neuron.error = nextErrors[i];
            }
            errors = nextErrors;
        }
    }

    updateWeights() {
        for (let layer of this.layers) {
            for (let neuron of layer.neurons) {
                for (let j = 0; j < neuron.weights.length; j++) {
                    neuron.weights[j] += this.learningRate * neuron.error * layer.lastInput[j];
                }
                neuron.bias += this.learningRate * neuron.error;
            }
        }
    }

    train(input, target) {
        this.forward(input);
        this.backward(target);
        this.updateWeights();
        return this.computeLoss(this.layers[this.layers.length - 1].neurons.map(n => n.output), target);
    }

    computeLoss(predicted, target) {
        let loss = 0;
        for (let i = 0; i < predicted.length; i++) {
            loss += Math.pow(target[i] - predicted[i], 2);
        }
        return loss / predicted.length;
    }

    getWeights() {
        return {
            inputSize: this.inputSize,
            hiddenSizes: this.hiddenSizes,
            outputSize: this.outputSize,
            hiddenActivation: this.hiddenActivation,
            outputActivation: this.outputActivation,
            learningRate: this.learningRate,
            layers: this.layers.map(layer => layer.getWeights()),
            lossHistory: this.lossHistory
        };
    }

    setWeights(data) {
        this.inputSize = data.inputSize;
        this.hiddenSizes = data.hiddenSizes;
        this.outputSize = data.outputSize;
        this.hiddenActivation = data.hiddenActivation;
        this.outputActivation = data.outputActivation;
        this.learningRate = data.learningRate || 0.1;
        this.lossHistory = data.lossHistory || [];
        
        // Handle JavaScript format (data.layers)
        if (data.layers && data.layers.length > 0) {
            for (let i = 0; i < this.layers.length; i++) {
                this.layers[i].setWeights(data.layers[i]);
            }
        }
        // Handle Pascal JSON format (data.hidden_layers and data.output_layer)
        else if (data.hidden_layers && data.output_layer) {
            // Load hidden layers
            for (let i = 0; i < data.hidden_layers.length; i++) {
                const layer = data.hidden_layers[i];
                if (layer.weights && layer.biases) {
                    for (let j = 0; j < this.layers[i].neurons.length; j++) {
                        this.layers[i].neurons[j].weights = layer.weights[j];
                        this.layers[i].neurons[j].bias = layer.biases[j];
                    }
                }
            }
            // Load output layer
            const outputLayer = data.output_layer;
            if (outputLayer.weights && outputLayer.biases) {
                const lastLayerIdx = this.layers.length - 1;
                for (let j = 0; j < this.layers[lastLayerIdx].neurons.length; j++) {
                    this.layers[lastLayerIdx].neurons[j].weights = outputLayer.weights[j];
                    this.layers[lastLayerIdx].neurons[j].bias = outputLayer.biases[j];
                }
            }
        }
    }
}

// ==================== DATA HANDLING ====================

let trainingData = [];
let normalizationParams = null;

function parseCSV(text) {
    const lines = text.trim().split('\n');
    const data = [];
    
    for (let line of lines) {
        if (!line.trim()) continue;
        const values = line.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
        if (values.length > 0) {
            data.push(values);
        }
    }
    
    return data;
}

function normalizeData(data) {
    if (data.length === 0) return { data: [], mins: [], maxs: [] };
    
    const mins = Array(data[0].length).fill(Infinity);
    const maxs = Array(data[0].length).fill(-Infinity);
    
    for (let sample of data) {
        for (let i = 0; i < sample.length; i++) {
            mins[i] = Math.min(mins[i], sample[i]);
            maxs[i] = Math.max(maxs[i], sample[i]);
        }
    }
    
    const normalized = data.map(sample => 
        sample.map((val, i) => {
            const range = maxs[i] - mins[i];
            if (range === 0) return 0.5;
            return (val - mins[i]) / range;
        })
    );
    
    return { data: normalized, mins: mins, maxs: maxs };
}

function loadCSV() {
    const fileInput = document.getElementById('csvFile');
    if (fileInput.files.length === 0) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
        trainingData = parseCSV(e.target.result);
        
        if (document.getElementById('normalizeData').checked && trainingData.length > 0) {
            const result = normalizeData(trainingData);
            trainingData = result.data;
            normalizationParams = { mins: result.mins, maxs: result.maxs };
            document.getElementById('dataStatus').innerText = `Loaded and normalized ${trainingData.length} samples`;
        } else {
            document.getElementById('dataStatus').innerText = `Loaded ${trainingData.length} samples`;
        }
    };
    reader.readAsText(fileInput.files[0]);
}

function loadCSVText() {
    const text = document.getElementById('csvPaste').value;
    trainingData = parseCSV(text);
    
    if (document.getElementById('normalizeData').checked && trainingData.length > 0) {
        const result = normalizeData(trainingData);
        trainingData = result.data;
        normalizationParams = { mins: result.mins, maxs: result.maxs };
        document.getElementById('dataStatus').innerText = `Loaded and normalized ${trainingData.length} samples`;
    } else {
        document.getElementById('dataStatus').innerText = `Loaded ${trainingData.length} samples`;
    }
}

// ==================== GLOBALS ====================

let currentMLP = null;
let lossHistory = [];

// ==================== UI UPDATES ====================

function updateSliderDisplay() {
    const lrSlider = document.getElementById('learningRate');
    const lrValue = Math.pow(10, parseFloat(lrSlider.value));
    document.getElementById('lrDisplay').textContent = lrValue.toFixed(4);
    if (currentMLP) currentMLP.learningRate = lrValue;

    const iterSlider = document.getElementById('trainIters');
    document.getElementById('iterDisplay').textContent = iterSlider.value;

    const dropoutSlider = document.getElementById('dropoutRate');
    document.getElementById('dropoutDisplay').textContent = parseFloat(dropoutSlider.value).toFixed(1);

    const l2Slider = document.getElementById('l2Lambda');
    document.getElementById('l2Display').textContent = parseFloat(l2Slider.value).toFixed(4);
}

function buildInputFields() {
    const container = document.getElementById('inputFields');
    container.innerHTML = '';
    
    if (!currentMLP) return;
    
    for (let i = 0; i < currentMLP.inputSize; i++) {
        const row = document.createElement('div');
        row.className = 'input-row';
        row.innerHTML = `
            <span class="input-label">In ${i}:</span>
            <input type="number" id="input${i}" value="0.5" min="0" max="1" step="0.01">
        `;
        container.appendChild(row);
    }
}

function createNetwork() {
    const inputSize = parseInt(document.getElementById('inputSize').value);
    const hiddenText = document.getElementById('hiddenSizes').value;
    const hiddenSizes = hiddenText.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
    const outputSize = parseInt(document.getElementById('outputSize').value);
    
    if (hiddenSizes.length === 0) {
        alert('Please specify at least one hidden layer size');
        return;
    }
    
    const hiddenAct = document.getElementById('hiddenActivation').value;
    const outputAct = document.getElementById('outputActivation').value;
    
    currentMLP = new MultiLayerPerceptron(inputSize, hiddenSizes, outputSize, hiddenAct, outputAct);
    currentMLP.learningRate = Math.pow(10, parseFloat(document.getElementById('learningRate').value));
    
    buildInputFields();
    lossHistory = [];
    updateLossChart();
    document.getElementById('output').innerHTML = '<div class="success-msg">Network created successfully</div>';
    document.getElementById('trainBtn').disabled = false;
    document.getElementById('predictBtn').disabled = false;
}

function randomizeInputs() {
    for (let i = 0; i < (currentMLP ? currentMLP.inputSize : 0); i++) {
        const elem = document.getElementById(`input${i}`);
        if (elem) elem.value = Math.random().toFixed(2);
    }
}

function trainModel() {
    if (!currentMLP) return;
    
    const inputs = Array.from({length: currentMLP.inputSize}, (_, i) => 
        parseFloat(document.getElementById(`input${i}`).value) || 0
    );
    
    const targetText = document.getElementById('targetOutput').value;
    const target = targetText.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
    
    if (target.length === 0) {
        alert('Please specify target output');
        return;
    }
    
    const iterations = parseInt(document.getElementById('trainIters').value);
    
    lossHistory = [];
    for (let iter = 0; iter < iterations; iter++) {
        const loss = currentMLP.train(inputs, target);
        lossHistory.push(loss);
    }
    
    updateLossChart();
    const finalOutput = currentMLP.predict(inputs);
    
    let msg = `<div class="success-msg">Training completed (${iterations} iterations)<br>`;
    msg += `Final loss: ${lossHistory[lossHistory.length - 1].toFixed(6)}<br>`;
    msg += `Output: ${finalOutput.map(v => v.toFixed(6)).join(', ')}</div>`;
    document.getElementById('output').innerHTML = msg;
}

function predictModel() {
    if (!currentMLP) return;
    
    let inputs = Array.from({length: currentMLP.inputSize}, (_, i) => 
        parseFloat(document.getElementById(`input${i}`).value) || 0
    );
    
    // Apply normalization if available
    if (normalizationParams) {
        inputs = inputs.map((val, idx) => {
            const range = normalizationParams.maxs[idx] - normalizationParams.mins[idx];
            if (range === 0) return 0.5;
            return (val - normalizationParams.mins[idx]) / range;
        });
    }
    
    const output = currentMLP.predict(inputs);
    
    let msg = '<div class="success-msg">Prediction:<br>';
    for (let i = 0; i < output.length; i++) {
        msg += `Output ${i}: ${output[i].toFixed(6)}<br>`;
    }
    msg += '</div>';
    document.getElementById('output').innerHTML = msg;
}

function updateLossChart() {
    const canvas = document.getElementById('lossChart');
    const ctx = canvas.getContext('2d');
    
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = 200;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (lossHistory.length === 0) return;
    
    const padding = 40;
    const width = canvas.width - 2 * padding;
    const height = canvas.height - 2 * padding;
    
    const maxLoss = Math.max(...lossHistory, 0.001);
    
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    for (let i = 0; i < lossHistory.length; i++) {
        const x = padding + (i / (lossHistory.length - 1 || 1)) * width;
        const y = canvas.height - padding - (lossHistory[i] / maxLoss) * height;
        
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();
    
    // Axes
    ctx.strokeStyle = '#1e293b';
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, canvas.height - padding);
    ctx.lineTo(canvas.width - padding, canvas.height - padding);
    ctx.stroke();
    
    // Labels
    ctx.fillStyle = '#1e293b';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(maxLoss.toFixed(3), padding - 5, padding + 5);
    ctx.textAlign = 'center';
    ctx.fillText(lossHistory.length - 1, canvas.width - padding, canvas.height - 20);
}

function saveModelDialog() {
    if (!currentMLP) {
        alert('No model to save');
        return;
    }
    
    const data = JSON.stringify(currentMLP.getWeights(), null, 2);
    const blob = new Blob([data], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'mlp_model.json';
    a.click();
    URL.revokeObjectURL(url);
}

function loadModelDialog() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const data = JSON.parse(event.target.result);
                
                // Handle both camelCase (JavaScript) and snake_case (Pascal) formats
                const inputSize = data.inputSize || data.input_size;
                const hiddenSizes = data.hiddenSizes || data.hidden_sizes;
                const outputSize = data.outputSize || data.output_size;
                const hiddenActivation = data.hiddenActivation || data.hidden_activation || 'sigmoid';
                const outputActivation = data.outputActivation || data.output_activation || 'sigmoid';
                
                currentMLP = new MultiLayerPerceptron(inputSize, hiddenSizes, outputSize, hiddenActivation, outputActivation);
                currentMLP.setWeights({
                    inputSize: inputSize,
                    hiddenSizes: hiddenSizes,
                    outputSize: outputSize,
                    hiddenActivation: hiddenActivation,
                    outputActivation: outputActivation,
                    learningRate: data.learningRate || data.learning_rate || 0.1,
                    lossHistory: data.lossHistory || []
                });
                
                document.getElementById('inputSize').value = inputSize;
                document.getElementById('hiddenSizes').value = hiddenSizes.join(',');
                document.getElementById('outputSize').value = outputSize;
                document.getElementById('hiddenActivation').value = hiddenActivation;
                document.getElementById('outputActivation').value = outputActivation;
                
                buildInputFields();
                lossHistory = data.lossHistory || [];
                updateLossChart();
                
                document.getElementById('output').innerHTML = '<div class="success-msg">Model loaded successfully</div>';
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('predictBtn').disabled = false;
            } catch (err) {
                alert('Failed to load model: ' + err.message);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

function resetModel() {
    currentMLP = null;
    lossHistory = [];
    document.getElementById('output').innerHTML = '';
    document.getElementById('inputFields').innerHTML = '';
    document.getElementById('trainBtn').disabled = true;
    document.getElementById('predictBtn').disabled = true;
    updateLossChart();
}

// ==================== INITIALIZATION ====================

buildInputFields();
updateSliderDisplay();
updateLossChart();
    </script>
</body>
</html>
