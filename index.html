<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Multi-Layer Perceptron Trainer with Evaluation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 2rem;
        }

        input,
        select,
        textarea,
        button {
            margin: 0.5rem 0;
        }

        .section {
            margin-bottom: 2rem;
            border-bottom: 1px solid #ccc;
            padding-bottom: 1rem;
        }

        label {
            display: block;
            margin-top: 0.5rem;
        }

        .results {
            background-color: #f5f5f5;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 5px;
        }

        .metric {
            margin: 0.5rem 0;
            font-weight: bold;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        .epoch-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .epoch-info {
            font-style: italic;
            color: #666;
            margin-top: 0.5rem;
        }

        .warning {
            color: #b36b00;
            background-color: #fff3cd;
            padding: 0.5rem;
            border-radius: 4px;
            margin: 0.5rem 0;
        }

        .error-msg {
            color: #721c24;
            background-color: #f8d7da;
            padding: 0.5rem;
            border-radius: 4px;
            margin: 0.5rem 0;
        }
    </style>
</head>

<body>
    <h1>Multi-Layer Perceptron Trainer with Evaluation</h1>

    <div class="section">
        <h2>Network Configuration</h2>
        <label>Input Size: <input type="number" id="inputSize" value="10" min="1"></label>
        <label>Hidden Layer Sizes (comma separated): <input type="text" id="hiddenSizes" value="8,8,8"></label>
        <label>Output Size: <input type="number" id="outputSize" value="3" min="1"></label>
        <label>Hidden Layer Activation:
            <select id="hiddenActivation">
                <option value="sigmoid" selected>Sigmoid</option>
                <option value="tanh">Tanh</option>
                <option value="relu">ReLU</option>
            </select>
        </label>
        <label>Output Layer Activation:
            <select id="outputActivation">
                <option value="softmax" selected>Softmax</option>
                <option value="sigmoid">Sigmoid</option>
                <option value="tanh">Tanh</option>
                <option value="relu">ReLU</option>
            </select>
        </label>
        <label>Learning Rate: <input type="number" id="learningRate" value="0.1" step="0.01" min="0.001"
                max="1"></label>
        <label>Optimizer:
            <select id="optimizer">
                <option value="sgd" selected>SGD</option>
                <option value="adam">Adam</option>
                <option value="rmsprop">RMSProp</option>
            </select>
        </label>
        <button onclick="createNetwork()">Create Network</button>
        <span id="networkStatus" style="margin-left:1rem;"></span>
    </div>

    <div class="section">
        <h2>Regularization</h2>
        <label>Dropout Rate (0-1): <input type="number" id="dropoutRate" value="0" step="0.1" min="0" max="0.9"></label>
        <label>L2 Regularization (lambda): <input type="number" id="l2Lambda" value="0" step="0.0001" min="0" max="0.1"></label>
    </div>

    <div class="section">
        <h2>Training Configuration</h2>
        <div class="epoch-controls">
            <label>Training Epochs:
                <input type="number" id="trainingEpochs" value="50" min="1" max="10000" step="1">
            </label>
            <label>Validation Epochs:
                <input type="number" id="validationEpochs" value="30" min="1" max="1000" step="1">
            </label>
            <label>Batch Size:
                <select id="batchSize">
                    <option value="1">1 (Online Learning)</option>
                    <option value="32" selected>32</option>
                    <option value="64">64</option>
                    <option value="128">128</option>
                    <option value="all">Full Batch</option>
                </select>
            </label>
        </div>
        <label>
            <input type="checkbox" id="enableLRDecay"> Enable Learning Rate Decay
            <input type="number" id="lrDecayRate" value="0.95" step="0.01" min="0.5" max="1" style="width:60px"> per
            <input type="number" id="lrDecayEpochs" value="10" step="1" min="1" style="width:50px"> epochs
        </label>
        <label>
            <input type="checkbox" id="enableEarlyStopping"> Enable Early Stopping after
            <input type="number" id="earlyStoppingPatience" value="10" step="1" min="1" style="width:50px"> epochs without improvement
        </label>
        <div class="epoch-info">
            ℹ️ Training Epochs: Full passes through training data for regular training<br>
            ℹ️ Validation Epochs: Epochs used for each fold in K-Fold cross-validation<br>
            ℹ️ Batch Size: Number of samples processed before updating weights
        </div>
    </div>

    <div class="section">
        <h2>Load Training Data</h2>
        <input type="file" id="csvFile" accept=".csv">
        <button onclick="loadCSV()">Load CSV</button>
        <span id="dataStatus"></span>
        <div id="dataWarnings"></div>
        <br>
        <label>Or paste CSV data:</label>
        <textarea id="csvPaste" rows="5" cols="60"></textarea>
        <button onclick="loadCSVText()">Load Pasted CSV</button>
        <br>
        <label><input type="checkbox" id="normalizeData" checked> Normalize input features to [0,1]</label>
    </div>

    <div class="section">
        <h2>Generate Test Data</h2>
        <label>Number of Samples per Class: <input type="number" id="samplesPerClass" value="2500" min="100"></label>
        <button onclick="generateTestData()">Generate Test Data</button>
        <span id="generateStatus"></span>
    </div>

    <div class="section">
        <h2>Model Evaluation</h2>
        <label>Number of Folds: <input type="number" id="numFolds" value="10" min="2" max="20"></label>
        <button onclick="runKFoldValidation()">Run K-Fold Cross Validation</button>
        <button onclick="runAllMetrics()">Run All Evaluation Metrics</button>
        <div id="evaluationResults"></div>
    </div>

    <div class="section">
        <h2>Save/Load Model</h2>
        <button onclick="saveModel()">Save Model</button>
        <button onclick="loadModel()">Load Model</button>
        <input type="file" id="modelFile" accept=".json">
        <span id="modelStatus"></span>
    </div>

    <div class="section">
        <h2>Train Network</h2>
        <button onclick="trainNetwork()">Train Network</button>
        <button onclick="trainNetworkWithProgress()">Train with Progress</button>
        <div id="trainStatus"></div>
        <div id="trainingProgress"></div>
        <div id="validationLossChart"></div>
    </div>

    <div class="section">
        <h2>Predict</h2>
        <label>Input (comma separated): <input type="text" id="predictInput"
                value="0.19,0.21,0.32,0.43,0.54,0.65,0.77,0.88,0.99,0.01"></label>
        <button onclick="predictInput()">Predict</button>
        <div id="predictOutput"></div>
    </div>

    <script>
        const EPSILON = 1e-15;

        class ActivationFunctions {
            static softmax(x) {
                if (!(x instanceof Array)) return null;

                const maxVal = Math.max(...x);
                let sum = 0;
                const expValues = [];
                for (let i = 0; i < x.length; i++) {
                    const expVal = Math.exp(x[i] - maxVal);
                    expValues.push(expVal);
                    sum += expVal;
                }

                const result = [];
                for (let i = 0; i < x.length; i++) {
                    let prob = expValues[i] / sum;
                    prob = Math.max(EPSILON, Math.min(1 - EPSILON, prob));
                    result.push(prob);
                }
                return result;
            }

            static dSoftmax(labels, x) {
                if (!(x instanceof Array)) return null;

                const result = [];
                for (let i = 0; i < x.length; i++) {
                    result[i] = labels[i] - x[i];
                }
                return result;
            }

            static sigmoid(x) {
                if (Array.isArray(x)) {
                    return x.map(val => 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, val)))));
                }
                return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
            }

            static dSigmoid(x) {
                if (Array.isArray(x)) {
                    return x.map(val => val * (1 - val));
                }
                return x * (1 - x);
            }

            static tanh(x) {
                if (Array.isArray(x)) {
                    return x.map(val => Math.tanh(val));
                }
                return Math.tanh(x);
            }

            static dTanh(x) {
                if (Array.isArray(x)) {
                    return x.map(val => 1 - (val * val));
                }
                return 1 - (x * x);
            }

            static relu(x) {
                if (Array.isArray(x)) {
                    return x.map(val => Math.max(0, val));
                }
                return Math.max(0, x);
            }

            static dRelu(x) {
                if (Array.isArray(x)) {
                    return x.map(val => val > 0 ? 1 : 0);
                }
                return x > 0 ? 1 : 0;
            }

            static apply(activationType, x) {
                switch (activationType) {
                    case 'sigmoid': return this.sigmoid(x);
                    case 'tanh': return this.tanh(x);
                    case 'relu': return this.relu(x);
                    case 'softmax': return this.softmax(x);
                    default: return this.sigmoid(x);
                }
            }

            static applyDerivative(activationType, x, target = null) {
                switch (activationType) {
                    case 'sigmoid': return this.dSigmoid(x);
                    case 'tanh': return this.dTanh(x);
                    case 'relu': return this.dRelu(x);
                    case 'softmax': return target ? this.dSoftmax(target, x) : x;
                    default: return this.dSigmoid(x);
                }
            }
        }

        class MLEvaluation {
            static kFoldCrossValidation(data, numFolds, mlp, epochs = null) {
                const numSamples = data.length;
                const foldSize = Math.floor(numSamples / numFolds);
                let sumAccuracy = 0;

                const validationEpochs = epochs || parseInt(document.getElementById("validationEpochs").value);

                for (let i = 0; i < numFolds; i++) {
                    const foldMLP = this.cloneMLP(mlp);

                    const testSet = [];
                    for (let j = 0; j < foldSize; j++) {
                        testSet.push(data[i * foldSize + j]);
                    }

                    const trainSet = [];
                    for (let j = 0; j < numSamples; j++) {
                        if (j >= i * foldSize && j < (i + 1) * foldSize) {
                            continue;
                        }
                        trainSet.push(data[j]);
                    }

                    for (let epoch = 0; epoch < validationEpochs; epoch++) {
                        for (let k = 0; k < trainSet.length; k++) {
                            foldMLP.train(trainSet[k].input, trainSet[k].target);
                        }
                    }

                    let correctPredictions = 0;
                    for (let j = 0; j < testSet.length; j++) {
                        const prediction = foldMLP.predict(testSet[j].input);
                        const predictedClass = this.getMaxIndex(prediction);
                        const actualClass = this.getMaxIndex(testSet[j].target);

                        if (predictedClass === actualClass) {
                            correctPredictions++;
                        }
                    }

                    sumAccuracy += correctPredictions;
                }

                return sumAccuracy / numSamples;
            }

            static cloneMLP(mlp) {
                const jsonStr = mlp.toJSON();
                return TMultiLayerPerceptron.fromJSON(jsonStr);
            }

            static trainWithBatches(mlp, data, epochs, batchSize, progressCallback = null) {
                const totalSamples = data.length;
                let actualBatchSize = batchSize === 'all' ? totalSamples : parseInt(batchSize);
                
                if (actualBatchSize > totalSamples) {
                    actualBatchSize = totalSamples;
                }

                const enableLRDecay = document.getElementById("enableLRDecay")?.checked || false;
                const lrDecayRate = parseFloat(document.getElementById("lrDecayRate")?.value || 0.95);
                const lrDecayEpochs = parseInt(document.getElementById("lrDecayEpochs")?.value || 10);
                const initialLR = mlp.learningRate;

                const enableEarlyStopping = document.getElementById("enableEarlyStopping")?.checked || false;
                const patience = parseInt(document.getElementById("earlyStoppingPatience")?.value || 10);
                let bestLoss = Infinity;
                let epochsWithoutImprovement = 0;
                const validationLosses = [];

                const validationSplit = 0.1;
                const shuffledData = [...data].sort(() => Math.random() - 0.5);
                const valSize = Math.floor(shuffledData.length * validationSplit);
                const valData = shuffledData.slice(0, valSize);
                const trainData = shuffledData.slice(valSize);

                for (let epoch = 0; epoch < epochs; epoch++) {
                    if (enableLRDecay && epoch > 0 && epoch % lrDecayEpochs === 0) {
                        mlp.learningRate *= lrDecayRate;
                    }

                    const epochData = [...trainData].sort(() => Math.random() - 0.5);

                    for (let i = 0; i < epochData.length; i += actualBatchSize) {
                        const batchEnd = Math.min(i + actualBatchSize, epochData.length);
                        const batch = epochData.slice(i, batchEnd);

                        for (let j = 0; j < batch.length; j++) {
                            mlp.train(batch[j].input, batch[j].target);
                        }
                    }

                    if (enableEarlyStopping && valData.length > 0) {
                        let valLoss = 0;
                        for (let j = 0; j < valData.length; j++) {
                            const pred = mlp.predict(valData[j].input);
                            valLoss += mlp.computeLoss(pred, valData[j].target);
                        }
                        valLoss /= valData.length;
                        validationLosses.push(valLoss);

                        if (valLoss < bestLoss - EPSILON) {
                            bestLoss = valLoss;
                            epochsWithoutImprovement = 0;
                        } else {
                            epochsWithoutImprovement++;
                        }

                        if (epochsWithoutImprovement >= patience) {
                            if (progressCallback) {
                                progressCallback(epoch + 1, epochs, validationLosses, true);
                            }
                            mlp.learningRate = initialLR;
                            return;
                        }
                    }

                    if (progressCallback && epoch % 10 === 0) {
                        progressCallback(epoch + 1, epochs, validationLosses, false);
                    }
                }

                mlp.learningRate = initialLR;

                if (progressCallback) {
                    progressCallback(epochs, epochs, validationLosses, false);
                }
            }

            static precisionScore(data, mlp, classIndex = 0) {
                let truePositives = 0;
                let falsePositives = 0;

                for (let i = 0; i < data.length; i++) {
                    const prediction = mlp.predict(data[i].input);
                    const predictedClass = this.getMaxIndex(prediction);
                    const actualClass = this.getMaxIndex(data[i].target);

                    if (predictedClass === classIndex) {
                        if (actualClass === classIndex) {
                            truePositives++;
                        } else {
                            falsePositives++;
                        }
                    }
                }

                if (truePositives + falsePositives === 0) {
                    return 0;
                }
                return truePositives / (truePositives + falsePositives);
            }

            static recallScore(data, mlp, classIndex = 0) {
                let truePositives = 0;
                let falseNegatives = 0;

                for (let i = 0; i < data.length; i++) {
                    const prediction = mlp.predict(data[i].input);
                    const predictedClass = this.getMaxIndex(prediction);
                    const actualClass = this.getMaxIndex(data[i].target);

                    if (actualClass === classIndex) {
                        if (predictedClass === classIndex) {
                            truePositives++;
                        } else {
                            falseNegatives++;
                        }
                    }
                }

                if (truePositives + falseNegatives === 0) {
                    return 0;
                }
                return truePositives / (truePositives + falseNegatives);
            }

            static f1Score(precision, recall) {
                if (precision + recall === 0) {
                    return 0;
                }
                return 2 * (precision * recall) / (precision + recall);
            }

            static getMaxIndex(array) {
                let maxIndex = 0;
                for (let i = 1; i < array.length; i++) {
                    if (array[i] > array[maxIndex]) {
                        maxIndex = i;
                    }
                }
                return maxIndex;
            }

            static generateTestData(samplesPerClass, inputSize, numClasses) {
                const data = [];

                for (let classIndex = 0; classIndex < numClasses; classIndex++) {
                    for (let i = 0; i < samplesPerClass; i++) {
                        const input = [];
                        const target = new Array(numClasses).fill(0);
                        target[classIndex] = 1;

                        for (let j = 0; j < inputSize; j++) {
                            switch (classIndex) {
                                case 0:
                                    input.push(Math.random() * 0.5);
                                    break;
                                case 1:
                                    input.push(0.5 + Math.random() * 0.5);
                                    break;
                                case 2:
                                    input.push(j % 2 === 0 ? Math.random() * 0.5 : 0.5 + Math.random() * 0.5);
                                    break;
                                default:
                                    input.push(Math.random());
                                    break;
                            }
                        }

                        data.push(new TDataPoint(input, target));
                    }
                }

                for (let i = data.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [data[i], data[j]] = [data[j], data[i]];
                }

                return data;
            }

            static normalizeData(data) {
                if (data.length === 0) return { data: [], mins: [], maxs: [] };

                const inputSize = data[0].input.length;
                const mins = new Array(inputSize).fill(Infinity);
                const maxs = new Array(inputSize).fill(-Infinity);

                for (let i = 0; i < data.length; i++) {
                    for (let j = 0; j < inputSize; j++) {
                        if (data[i].input[j] < mins[j]) mins[j] = data[i].input[j];
                        if (data[i].input[j] > maxs[j]) maxs[j] = data[i].input[j];
                    }
                }

                const normalizedData = data.map(point => {
                    const normalizedInput = point.input.map((val, idx) => {
                        const range = maxs[idx] - mins[idx];
                        if (range === 0) return 0.5;
                        return (val - mins[idx]) / range;
                    });
                    return new TDataPoint(normalizedInput, point.target);
                });

                return { data: normalizedData, mins, maxs };
            }

            static checkDataQuality(data) {
                const warnings = [];
                if (data.length === 0) return warnings;

                const inputSize = data[0].input.length;

                for (let j = 0; j < inputSize; j++) {
                    let min = Infinity, max = -Infinity, sum = 0;
                    for (let i = 0; i < data.length; i++) {
                        const val = data[i].input[j];
                        if (val < min) min = val;
                        if (val > max) max = val;
                        sum += val;
                    }
                    const mean = sum / data.length;
                    const range = max - min;

                    if (range > 100) {
                        warnings.push(`Feature ${j}: Large range (${min.toFixed(2)} to ${max.toFixed(2)}). Consider normalizing.`);
                    }
                    if (min < -10 || max > 10) {
                        warnings.push(`Feature ${j}: Values outside [-10, 10] range. Consider normalizing.`);
                    }
                }

                return warnings;
            }
        }

        class TDataPoint {
            constructor(input, target) {
                this.input = input;
                this.target = target;
            }
        }

        class TNeuron {
            constructor() {
                this.weights = [];
                this.bias = 0;
                this.output = 0;
                this.error = 0;
                this.m = [];
                this.v = [];
                this.mBias = 0;
                this.vBias = 0;
            }
        }

        class TLayer {
            constructor() {
                this.neurons = [];
                this.activationType = 'sigmoid';
            }
        }

        class TMultiLayerPerceptron {
            constructor(inputSize, hiddenSizes, outputSize, hiddenActivation = 'sigmoid', outputActivation = 'sigmoid') {
                this.learningRate = 0.1;
                this.inputLayer = new TLayer();
                this.hiddenLayers = [];
                this.outputLayer = new TLayer();
                this.hiddenActivation = hiddenActivation;
                this.outputActivation = outputActivation;
                this.optimizer = 'sgd';
                this.dropoutRate = 0;
                this.l2Lambda = 0;
                this.beta1 = 0.9;
                this.beta2 = 0.999;
                this.timestep = 0;
                this.dropoutMasks = [];
                this.isTraining = true;
                this.initialize(inputSize, hiddenSizes, outputSize);
            }

            initializeWeights(inputSize, outputSize, activation) {
                let limit;
                if (activation === 'relu') {
                    limit = Math.sqrt(2.0 / inputSize);
                } else {
                    limit = Math.sqrt(6.0 / (inputSize + outputSize));
                }
                return new Array(inputSize).fill(0).map(() =>
                    (Math.random() * 2 - 1) * limit
                );
            }

            initialize(inputSize, hiddenSizes, outputSize) {
                this.inputLayer.neurons = [];
                for (let i = 0; i < inputSize; i++) {
                    this.inputLayer.neurons.push(new TNeuron());
                    this.inputLayer.neurons[i].output = 0;
                }

                this.hiddenLayers = [];
                let prevSize = inputSize;
                hiddenSizes.forEach((size, idx) => {
                    let layer = new TLayer();
                    layer.activationType = this.hiddenActivation;
                    const nextSize = idx < hiddenSizes.length - 1 ? hiddenSizes[idx + 1] : outputSize;
                    for (let i = 0; i < size; i++) {
                        let neuron = new TNeuron();
                        neuron.weights = this.initializeWeights(prevSize, size, this.hiddenActivation);
                        neuron.bias = 0;
                        neuron.m = new Array(prevSize).fill(0);
                        neuron.v = new Array(prevSize).fill(0);
                        layer.neurons.push(neuron);
                    }
                    this.hiddenLayers.push(layer);
                    prevSize = size;
                });

                this.outputLayer = new TLayer();
                this.outputLayer.activationType = this.outputActivation;
                for (let i = 0; i < outputSize; i++) {
                    let neuron = new TNeuron();
                    neuron.weights = this.initializeWeights(prevSize, outputSize, this.outputActivation);
                    neuron.bias = 0;
                    neuron.m = new Array(prevSize).fill(0);
                    neuron.v = new Array(prevSize).fill(0);
                    this.outputLayer.neurons.push(neuron);
                }
            }

            applyDropout(layerOutputs, layerIndex) {
                if (!this.isTraining || this.dropoutRate <= 0) {
                    return layerOutputs;
                }

                const mask = layerOutputs.map(() => Math.random() > this.dropoutRate ? 1 : 0);
                this.dropoutMasks[layerIndex] = mask;

                const scale = 1 / (1 - this.dropoutRate);
                return layerOutputs.map((val, idx) => val * mask[idx] * scale);
            }

            feedForward(input) {
                for (let i = 0; i < this.inputLayer.neurons.length; i++) {
                    this.inputLayer.neurons[i].output = input[i];
                }

                let prevOutputs = input;
                this.dropoutMasks = [];

                for (let k = 0; k < this.hiddenLayers.length; k++) {
                    let curOutputs = [];

                    for (let i = 0; i < this.hiddenLayers[k].neurons.length; i++) {
                        let sum = this.hiddenLayers[k].neurons[i].bias;

                        for (let j = 0; j < prevOutputs.length; j++) {
                            sum += prevOutputs[j] * this.hiddenLayers[k].neurons[i].weights[j];
                        }

                        this.hiddenLayers[k].neurons[i].output = ActivationFunctions.apply(
                            this.hiddenLayers[k].activationType, sum
                        );

                        curOutputs.push(this.hiddenLayers[k].neurons[i].output);
                    }

                    curOutputs = this.applyDropout(curOutputs, k);
                    for (let i = 0; i < curOutputs.length; i++) {
                        this.hiddenLayers[k].neurons[i].output = curOutputs[i];
                    }

                    prevOutputs = curOutputs;
                }

                let outputSums = [];
                for (let i = 0; i < this.outputLayer.neurons.length; i++) {
                    let sum = this.outputLayer.neurons[i].bias;

                    for (let j = 0; j < prevOutputs.length; j++) {
                        sum += prevOutputs[j] * this.outputLayer.neurons[i].weights[j];
                    }

                    outputSums.push(sum);
                }

                let output;
                if (this.outputActivation === 'softmax') {
                    output = ActivationFunctions.softmax(outputSums);
                    for (let i = 0; i < this.outputLayer.neurons.length; i++) {
                        this.outputLayer.neurons[i].output = output[i];
                    }
                } else {
                    output = [];
                    for (let i = 0; i < this.outputLayer.neurons.length; i++) {
                        this.outputLayer.neurons[i].output = ActivationFunctions.apply(
                            this.outputActivation, outputSums[i]
                        );
                        output.push(this.outputLayer.neurons[i].output);
                    }
                }

                return output;
            }

            computeLoss(predicted, target) {
                let loss = 0;
                if (this.outputActivation === 'softmax') {
                    for (let i = 0; i < target.length; i++) {
                        const p = Math.max(EPSILON, Math.min(1 - EPSILON, predicted[i]));
                        loss -= target[i] * Math.log(p);
                    }
                } else {
                    for (let i = 0; i < target.length; i++) {
                        loss += 0.5 * Math.pow(target[i] - predicted[i], 2);
                    }
                }

                if (this.l2Lambda > 0) {
                    let l2Sum = 0;
                    for (let k = 0; k < this.hiddenLayers.length; k++) {
                        for (let i = 0; i < this.hiddenLayers[k].neurons.length; i++) {
                            for (let j = 0; j < this.hiddenLayers[k].neurons[i].weights.length; j++) {
                                l2Sum += Math.pow(this.hiddenLayers[k].neurons[i].weights[j], 2);
                            }
                        }
                    }
                    for (let i = 0; i < this.outputLayer.neurons.length; i++) {
                        for (let j = 0; j < this.outputLayer.neurons[i].weights.length; j++) {
                            l2Sum += Math.pow(this.outputLayer.neurons[i].weights[j], 2);
                        }
                    }
                    loss += 0.5 * this.l2Lambda * l2Sum;
                }

                return loss;
            }

            backPropagate(target) {
                if (this.outputActivation === 'softmax') {
                    let derivatives = ActivationFunctions.dSoftmax(target,
                        this.outputLayer.neurons.map(n => n.output)
                    );
                    for (let i = 0; i < this.outputLayer.neurons.length; i++) {
                        this.outputLayer.neurons[i].error = derivatives[i];
                    }
                } else {
                    for (let i = 0; i < this.outputLayer.neurons.length; i++) {
                        let o = this.outputLayer.neurons[i].output;
                        let derivative = ActivationFunctions.applyDerivative(this.outputActivation, o);
                        this.outputLayer.neurons[i].error = derivative * (target[i] - o);
                    }
                }

                for (let k = this.hiddenLayers.length - 1; k >= 0; k--) {
                    for (let i = 0; i < this.hiddenLayers[k].neurons.length; i++) {
                        let neuron = this.hiddenLayers[k].neurons[i];
                        let sum = 0;

                        if (k === this.hiddenLayers.length - 1) {
                            for (let j = 0; j < this.outputLayer.neurons.length; j++) {
                                sum += this.outputLayer.neurons[j].error * this.outputLayer.neurons[j].weights[i];
                            }
                        } else {
                            for (let j = 0; j < this.hiddenLayers[k + 1].neurons.length; j++) {
                                sum += this.hiddenLayers[k + 1].neurons[j].error * this.hiddenLayers[k + 1].neurons[j].weights[i];
                            }
                        }

                        let derivative = ActivationFunctions.applyDerivative(
                            this.hiddenLayers[k].activationType, neuron.output
                        );

                        if (this.dropoutMasks[k] && this.dropoutMasks[k][i] === 0) {
                            neuron.error = 0;
                        } else {
                            neuron.error = derivative * sum;
                        }
                    }
                }
            }

            updateWeights(input) {
                this.timestep++;

                let layerOutputs = [input];
                for (let k = 0; k < this.hiddenLayers.length; k++) {
                    let outputs = [];
                    for (let i = 0; i < this.hiddenLayers[k].neurons.length; i++) {
                        outputs.push(this.hiddenLayers[k].neurons[i].output);
                    }
                    layerOutputs.push(outputs);
                }

                let lastHiddenOutputs = layerOutputs[layerOutputs.length - 1];
                for (let i = 0; i < this.outputLayer.neurons.length; i++) {
                    let neuron = this.outputLayer.neurons[i];
                    this.updateNeuronWeights(neuron, lastHiddenOutputs);
                }

                for (let k = this.hiddenLayers.length - 1; k >= 0; k--) {
                    let prevLayerOutputs = layerOutputs[k];
                    for (let i = 0; i < this.hiddenLayers[k].neurons.length; i++) {
                        let neuron = this.hiddenLayers[k].neurons[i];
                        this.updateNeuronWeights(neuron, prevLayerOutputs);
                    }
                }
            }

            updateNeuronWeights(neuron, prevLayerOutputs) {
                if (this.optimizer === 'adam') {
                    this.updateWeightsAdam(neuron, prevLayerOutputs);
                } else if (this.optimizer === 'rmsprop') {
                    this.updateWeightsRMSProp(neuron, prevLayerOutputs);
                } else {
                    this.updateWeightsSGD(neuron, prevLayerOutputs);
                }
            }

            updateWeightsSGD(neuron, prevLayerOutputs) {
                for (let j = 0; j < neuron.weights.length; j++) {
                    let gradient = neuron.error * prevLayerOutputs[j];
                    if (this.l2Lambda > 0) {
                        gradient -= this.l2Lambda * neuron.weights[j];
                    }
                    neuron.weights[j] += this.learningRate * gradient;
                }
                neuron.bias += this.learningRate * neuron.error;
            }

            updateWeightsAdam(neuron, prevLayerOutputs) {
                const eps = 1e-8;

                for (let j = 0; j < neuron.weights.length; j++) {
                    let gradient = -neuron.error * prevLayerOutputs[j];
                    if (this.l2Lambda > 0) {
                        gradient += this.l2Lambda * neuron.weights[j];
                    }

                    neuron.m[j] = this.beta1 * neuron.m[j] + (1 - this.beta1) * gradient;
                    neuron.v[j] = this.beta2 * neuron.v[j] + (1 - this.beta2) * gradient * gradient;

                    const mHat = neuron.m[j] / (1 - Math.pow(this.beta1, this.timestep));
                    const vHat = neuron.v[j] / (1 - Math.pow(this.beta2, this.timestep));

                    neuron.weights[j] -= this.learningRate * mHat / (Math.sqrt(vHat) + eps);
                }

                let biasGradient = -neuron.error;
                neuron.mBias = this.beta1 * neuron.mBias + (1 - this.beta1) * biasGradient;
                neuron.vBias = this.beta2 * neuron.vBias + (1 - this.beta2) * biasGradient * biasGradient;
                const mHatBias = neuron.mBias / (1 - Math.pow(this.beta1, this.timestep));
                const vHatBias = neuron.vBias / (1 - Math.pow(this.beta2, this.timestep));
                neuron.bias -= this.learningRate * mHatBias / (Math.sqrt(vHatBias) + 1e-8);
            }

            updateWeightsRMSProp(neuron, prevLayerOutputs) {
                const eps = 1e-8;
                const decay = 0.9;

                for (let j = 0; j < neuron.weights.length; j++) {
                    let gradient = -neuron.error * prevLayerOutputs[j];
                    if (this.l2Lambda > 0) {
                        gradient += this.l2Lambda * neuron.weights[j];
                    }

                    neuron.v[j] = decay * neuron.v[j] + (1 - decay) * gradient * gradient;
                    neuron.weights[j] -= this.learningRate * gradient / (Math.sqrt(neuron.v[j]) + eps);
                }

                let biasGradient = -neuron.error;
                neuron.vBias = decay * neuron.vBias + (1 - decay) * biasGradient * biasGradient;
                neuron.bias -= this.learningRate * biasGradient / (Math.sqrt(neuron.vBias) + eps);
            }

            predict(input) {
                this.isTraining = false;
                const result = this.feedForward(input);
                this.isTraining = true;
                return result;
            }

            train(input, target) {
                this.isTraining = true;
                this.feedForward(input);
                this.backPropagate(target);
                this.updateWeights(input);
            }

            toJSON() {
                return JSON.stringify({
                    learningRate: this.learningRate,
                    inputSize: this.inputLayer.neurons.length,
                    hiddenSizes: this.hiddenLayers.map(l => l.neurons.length),
                    outputSize: this.outputLayer.neurons.length,
                    hiddenActivation: this.hiddenActivation,
                    outputActivation: this.outputActivation,
                    optimizer: this.optimizer,
                    dropoutRate: this.dropoutRate,
                    l2Lambda: this.l2Lambda,
                    timestep: this.timestep,
                    hiddenLayers: this.hiddenLayers.map(layer => ({
                        activationType: layer.activationType,
                        neurons: layer.neurons.map(n => ({
                            weights: n.weights,
                            bias: n.bias,
                            m: n.m,
                            v: n.v,
                            mBias: n.mBias,
                            vBias: n.vBias,
                        }))
                    })),
                    outputLayer: {
                        activationType: this.outputLayer.activationType,
                        neurons: this.outputLayer.neurons.map(n => ({
                            weights: n.weights,
                            bias: n.bias,
                            m: n.m,
                            v: n.v,
                            mBias: n.mBias,
                            vBias: n.vBias,
                        }))
                    }
                });
            }

            static fromJSON(json) {
                let obj = JSON.parse(json);
                let mlp = new TMultiLayerPerceptron(
                    obj.inputSize,
                    obj.hiddenSizes,
                    obj.outputSize,
                    obj.hiddenActivation || 'sigmoid',
                    obj.outputActivation || 'sigmoid'
                );

                mlp.learningRate = obj.learningRate;
                mlp.optimizer = obj.optimizer || 'sgd';
                mlp.dropoutRate = obj.dropoutRate || 0;
                mlp.l2Lambda = obj.l2Lambda || 0;
                mlp.timestep = obj.timestep || 0;

                for (let k = 0; k < mlp.hiddenLayers.length; k++) {
                    if (obj.hiddenLayers[k].activationType) {
                        mlp.hiddenLayers[k].activationType = obj.hiddenLayers[k].activationType;
                    }
                    for (let i = 0; i < mlp.hiddenLayers[k].neurons.length; i++) {
                        mlp.hiddenLayers[k].neurons[i].weights = obj.hiddenLayers[k].neurons[i].weights;
                        mlp.hiddenLayers[k].neurons[i].bias = obj.hiddenLayers[k].neurons[i].bias;
                        mlp.hiddenLayers[k].neurons[i].m = obj.hiddenLayers[k].neurons[i].m || new Array(obj.hiddenLayers[k].neurons[i].weights.length).fill(0);
                        mlp.hiddenLayers[k].neurons[i].v = obj.hiddenLayers[k].neurons[i].v || new Array(obj.hiddenLayers[k].neurons[i].weights.length).fill(0);
                        mlp.hiddenLayers[k].neurons[i].mBias = obj.hiddenLayers[k].neurons[i].mBias || 0;
                        mlp.hiddenLayers[k].neurons[i].vBias = obj.hiddenLayers[k].neurons[i].vBias || 0;
                    }
                }

                if (obj.outputLayer.activationType) {
                    mlp.outputLayer.activationType = obj.outputLayer.activationType;
                }
                for (let i = 0; i < mlp.outputLayer.neurons.length; i++) {
                    mlp.outputLayer.neurons[i].weights = obj.outputLayer.neurons[i].weights;
                    mlp.outputLayer.neurons[i].bias = obj.outputLayer.neurons[i].bias;
                    mlp.outputLayer.neurons[i].m = obj.outputLayer.neurons[i].m || new Array(obj.outputLayer.neurons[i].weights.length).fill(0);
                    mlp.outputLayer.neurons[i].v = obj.outputLayer.neurons[i].v || new Array(obj.outputLayer.neurons[i].weights.length).fill(0);
                    mlp.outputLayer.neurons[i].mBias = obj.outputLayer.neurons[i].mBias || 0;
                    mlp.outputLayer.neurons[i].vBias = obj.outputLayer.neurons[i].vBias || 0;
                }

                return mlp;
            }
        }

        let mlp = null;
        let data = [];
        let normalizationParams = null;

        function parseCSV(text) {
            let lines = text.trim().split("\n");
            let points = [];
            let errors = [];
            let inputSize = parseInt(document.getElementById("inputSize").value);
            let outputSize = parseInt(document.getElementById("outputSize").value);
            let expectedCols = inputSize + outputSize;

            for (let lineNum = 0; lineNum < lines.length; lineNum++) {
                let line = lines[lineNum];
                if (line.trim() === "") continue;

                let arr = line.trim().split(",");

                if (arr.length !== expectedCols) {
                    errors.push(`Line ${lineNum + 1}: Expected ${expectedCols} columns, got ${arr.length}`);
                    continue;
                }

                let hasNonNumeric = false;
                let values = arr.map((val, idx) => {
                    let num = Number(val.trim());
                    if (isNaN(num)) {
                        hasNonNumeric = true;
                        errors.push(`Line ${lineNum + 1}, Col ${idx + 1}: Non-numeric value "${val.trim()}"`);
                        return 0;
                    }
                    return num;
                });

                if (hasNonNumeric) continue;

                let input = values.slice(0, inputSize);
                let target = values.slice(inputSize, inputSize + outputSize);

                points.push(new TDataPoint(input, target));
            }

            if (errors.length > 0) {
                const warningsDiv = document.getElementById("dataWarnings");
                warningsDiv.innerHTML = `<div class="error-msg">CSV parsing errors (showing first 5):<br>${errors.slice(0, 5).join('<br>')}</div>`;
            }

            return points;
        }

        function createNetwork() {
            let inputSize = parseInt(document.getElementById("inputSize").value);
            let hiddenSizes = document.getElementById("hiddenSizes").value
                .split(",").map(s => parseInt(s.trim())).filter(n => !isNaN(n));
            let outputSize = parseInt(document.getElementById("outputSize").value);
            let learningRate = parseFloat(document.getElementById("learningRate").value);
            let hiddenActivation = document.getElementById("hiddenActivation").value;
            let outputActivation = document.getElementById("outputActivation").value;
            let optimizer = document.getElementById("optimizer").value;
            let dropoutRate = parseFloat(document.getElementById("dropoutRate").value);
            let l2Lambda = parseFloat(document.getElementById("l2Lambda").value);

            mlp = new TMultiLayerPerceptron(inputSize, hiddenSizes, outputSize, hiddenActivation, outputActivation);
            mlp.learningRate = learningRate;
            mlp.optimizer = optimizer;
            mlp.dropoutRate = dropoutRate;
            mlp.l2Lambda = l2Lambda;

            document.getElementById("networkStatus").innerText =
                `Network created! Hidden: ${hiddenActivation}, Output: ${outputActivation}, Optimizer: ${optimizer}`;
        }


        function generateTestData() {
            let samplesPerClass = parseInt(document.getElementById("samplesPerClass").value);
            let inputSize = parseInt(document.getElementById("inputSize").value);
            let outputSize = parseInt(document.getElementById("outputSize").value);

            data = MLEvaluation.generateTestData(samplesPerClass, inputSize, outputSize);
            document.getElementById("generateStatus").innerText =
                `Generated ${data.length} test samples (${samplesPerClass} per class)`;
        }

        function runKFoldValidation() {
            if (!mlp) { alert("Create a network first."); return; }
            if (data.length === 0) { alert("Load or generate training data first."); return; }

            let numFolds = parseInt(document.getElementById("numFolds").value);
            let validationEpochs = parseInt(document.getElementById("validationEpochs").value);
            let resultsDiv = document.getElementById("evaluationResults");
            resultsDiv.innerHTML = `<p>Running K-Fold Cross Validation with ${validationEpochs} epochs per fold...</p>`;

            setTimeout(() => {
                let accuracy = MLEvaluation.kFoldCrossValidation(data, numFolds, mlp, validationEpochs);

                resultsDiv.innerHTML = `
                    <div class="results">
                        <h3>K-Fold Cross Validation Results (${numFolds} folds, ${validationEpochs} epochs each)</h3>
                        <div class="metric">Accuracy: ${(accuracy * 100).toFixed(2)}%</div>
                    </div>
                `;
            }, 100);
        }

        function runAllMetrics() {
            if (!mlp) { alert("Create a network first."); return; }
            if (data.length === 0) { alert("Load or generate training data first."); return; }

            let resultsDiv = document.getElementById("evaluationResults");
            let trainingEpochs = parseInt(document.getElementById("trainingEpochs").value);
            let validationEpochs = parseInt(document.getElementById("validationEpochs").value);

            resultsDiv.innerHTML = `<p>Running all evaluation metrics with ${trainingEpochs} training epochs...</p>`;

            setTimeout(() => {
                let numFolds = parseInt(document.getElementById("numFolds").value);
                let batchSize = document.getElementById("batchSize").value;

                MLEvaluation.trainWithBatches(mlp, data, trainingEpochs, batchSize);

                let outputSize = parseInt(document.getElementById("outputSize").value);
                let results = [];

                for (let classIndex = 0; classIndex < outputSize; classIndex++) {
                    let precision = MLEvaluation.precisionScore(data, mlp, classIndex);
                    let recall = MLEvaluation.recallScore(data, mlp, classIndex);
                    let f1 = MLEvaluation.f1Score(precision, recall);

                    results.push({
                        class: classIndex,
                        precision: precision,
                        recall: recall,
                        f1: f1
                    });
                }

                let accuracy = MLEvaluation.kFoldCrossValidation(data, numFolds, mlp, validationEpochs);

                let html = `
                    <div class="results">
                        <h3>Complete Evaluation Results</h3>
                        <div class="metric">Training Epochs: ${trainingEpochs}</div>
                        <div class="metric">Validation Epochs per Fold: ${validationEpochs}</div>
                        <div class="metric">Batch Size: ${batchSize}</div>
                        <div class="metric">Overall Accuracy: ${(accuracy * 100).toFixed(2)}%</div>

                        <table>
                            <tr>
                                <th>Class</th>
                                <th>Precision</th>
                                <th>Recall</th>
                                <th>F1 Score</th>
                            </tr>
                `;

                results.forEach(result => {
                    html += `
                        <tr>
                            <td>Class ${result.class}</td>
                            <td>${(result.precision * 100).toFixed(2)}%</td>
                            <td>${(result.recall * 100).toFixed(2)}%</td>
                            <td>${(result.f1 * 100).toFixed(2)}%</td>
                        </tr>
                    `;
                });

                let avgPrecision = results.reduce((sum, r) => sum + r.precision, 0) / results.length;
                let avgRecall = results.reduce((sum, r) => sum + r.recall, 0) / results.length;
                let avgF1 = results.reduce((sum, r) => sum + r.f1, 0) / results.length;

                html += `
                        <tr style="font-weight: bold; background-color: #e8e8e8;">
                            <td>Average</td>
                            <td>${(avgPrecision * 100).toFixed(2)}%</td>
                            <td>${(avgRecall * 100).toFixed(2)}%</td>
                            <td>${(avgF1 * 100).toFixed(2)}%</td>
                        </tr>
                    </table>
                    </div>
                `;

                resultsDiv.innerHTML = html;
            }, 100);
        }

        function trainNetwork() {

            if (!mlp) { alert("Create a network first."); return; }
            if (data.length === 0) { alert("Load training data first."); return; }

            let trainingEpochs = parseInt(document.getElementById("trainingEpochs").value);
            let batchSize = document.getElementById("batchSize").value;
            let statusDiv = document.getElementById("trainStatus");

            statusDiv.innerText = `Training for ${trainingEpochs} epochs with batch size ${batchSize}...`;

            setTimeout(() => {
                MLEvaluation.trainWithBatches(mlp, data, trainingEpochs, batchSize);
                statusDiv.innerText = `Training completed: ${trainingEpochs} epochs over ${data.length} data points.`;
            }, 20);
        }

        function trainNetworkWithProgress() {
            if (!mlp) { alert("Create a network first."); return; }
            if (data.length === 0) { alert("Load training data first."); return; }

            let trainingEpochs = parseInt(document.getElementById("trainingEpochs").value);
            let batchSize = document.getElementById("batchSize").value;
            let statusDiv = document.getElementById("trainStatus");
            let progressDiv = document.getElementById("trainingProgress");
            let chartDiv = document.getElementById("validationLossChart");

            statusDiv.innerText = `Training for ${trainingEpochs} epochs with batch size ${batchSize}...`;
            progressDiv.innerHTML = '<div>Epoch: 0 / ' + trainingEpochs + '</div>';

            setTimeout(() => {
                MLEvaluation.trainWithBatches(mlp, data, trainingEpochs, batchSize, (currentEpoch, totalEpochs, validationLosses, earlyStopped) => {
                    let lossInfo = '';
                    if (validationLosses.length > 0) {
                        const lastLoss = validationLosses[validationLosses.length - 1];
                        lossInfo = `<div>Validation Loss: ${lastLoss.toFixed(6)}</div>`;
                    }

                    progressDiv.innerHTML = `
                        <div>Epoch: ${currentEpoch} / ${totalEpochs}${earlyStopped ? ' (Early Stopped)' : ''}</div>
                        <div style="width: 300px; background-color: #f0f0f0; border-radius: 5px; margin-top: 5px;">
                            <div style="width: ${(currentEpoch / totalEpochs) * 100}%; background-color: #4CAF50; height: 20px; border-radius: 5px;"></div>
                        </div>
                        <div>${((currentEpoch / totalEpochs) * 100).toFixed(1)}% Complete</div>
                        ${lossInfo}
                    `;

                    if (validationLosses.length > 1) {
                        const maxLoss = Math.max(...validationLosses);
                        const chartHeight = 100;
                        const chartWidth = 300;
                        const barWidth = chartWidth / validationLosses.length;

                        let bars = validationLosses.map((loss, idx) => {
                            const height = (loss / maxLoss) * chartHeight;
                            return `<div style="display:inline-block;width:${barWidth}px;height:${height}px;background:#4CAF50;vertical-align:bottom;"></div>`;
                        }).join('');

                        chartDiv.innerHTML = `
                            <div style="margin-top:10px;">
                                <strong>Validation Loss History:</strong>
                                <div style="height:${chartHeight}px;width:${chartWidth}px;border:1px solid #ccc;display:flex;align-items:flex-end;">
                                    ${bars}
                                </div>
                            </div>
                        `;
                    }
                });

                statusDiv.innerText = `Training completed: ${trainingEpochs} epochs over ${data.length} data points.`;
            }, 20);
        }

        function loadCSV() {
            let fileInput = document.getElementById("csvFile");
            if (fileInput.files.length === 0) return;
            let reader = new FileReader();
            reader.onload = function (e) {
                document.getElementById("dataWarnings").innerHTML = '';
                data = parseCSV(e.target.result);

                const warnings = MLEvaluation.checkDataQuality(data);
                if (warnings.length > 0) {
                    document.getElementById("dataWarnings").innerHTML = `
                        <div class="warning">
                            <strong>Data quality warnings:</strong><br>
                            ${warnings.slice(0, 5).join('<br>')}
                            ${warnings.length > 5 ? `<br>... and ${warnings.length - 5} more` : ''}
                        </div>
                    `;
                }

                if (document.getElementById("normalizeData").checked && data.length > 0) {
                    const result = MLEvaluation.normalizeData(data);
                    data = result.data;
                    normalizationParams = { mins: result.mins, maxs: result.maxs };
                    document.getElementById("dataStatus").innerText = `Loaded and normalized ${data.length} data points.`;
                } else {
                    document.getElementById("dataStatus").innerText = `Loaded ${data.length} data points.`;
                }
            };
            reader.readAsText(fileInput.files[0]);
        }

        function loadCSVText() {
            let text = document.getElementById("csvPaste").value;
            document.getElementById("dataWarnings").innerHTML = '';
            data = parseCSV(text);

            const warnings = MLEvaluation.checkDataQuality(data);
            if (warnings.length > 0) {
                document.getElementById("dataWarnings").innerHTML = `
                    <div class="warning">
                        <strong>Data quality warnings:</strong><br>
                        ${warnings.slice(0, 5).join('<br>')}
                        ${warnings.length > 5 ? `<br>... and ${warnings.length - 5} more` : ''}
                    </div>
                `;
            }

            if (document.getElementById("normalizeData").checked && data.length > 0) {
                const result = MLEvaluation.normalizeData(data);
                data = result.data;
                normalizationParams = { mins: result.mins, maxs: result.maxs };
                document.getElementById("dataStatus").innerText = `Loaded and normalized ${data.length} data points.`;
            } else {
                document.getElementById("dataStatus").innerText = `Loaded ${data.length} data points.`;
            }
        }

        function saveModel() {
            if (!mlp) { alert("No model to save."); return; }
            let json = mlp.toJSON();
            let blob = new Blob([json], { type: "application/json" });
            let a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = "mlp-model.json";
            a.click();
            document.getElementById("modelStatus").innerText = "Model saved.";
        }

        function loadModel() {
            let fileInput = document.getElementById("modelFile");
            if (fileInput.files.length === 0) return;
            let reader = new FileReader();
            reader.onload = function (e) {
                mlp = TMultiLayerPerceptron.fromJSON(e.target.result);
                document.getElementById("modelStatus").innerText = "Model loaded!";
            };
            reader.readAsText(fileInput.files[0]);
        }

        function predictInput() {
            if (!mlp) { alert("Create/load network first."); return; }
            let input = document.getElementById("predictInput").value.split(",").map(Number);
            if (input.length !== mlp.inputLayer.neurons.length) {
                alert(`Input length must be ${mlp.inputLayer.neurons.length}`);
                return;
            }

            if (normalizationParams) {
                input = input.map((val, idx) => {
                    const range = normalizationParams.maxs[idx] - normalizationParams.mins[idx];
                    if (range === 0) return 0.5;
                    return (val - normalizationParams.mins[idx]) / range;
                });
            }

            let output = mlp.predict(input);
            let predictedClass = MLEvaluation.getMaxIndex(output);
            document.getElementById("predictOutput").innerHTML =
                `<strong>Raw Output:</strong> ${output.map(x => x.toFixed(4)).join(", ")}<br>
                 <strong>Predicted Class:</strong> ${predictedClass} (confidence: ${(output[predictedClass] * 100).toFixed(1)}%)`;
        }

    </script>
</body>

</html>
