<!--
MIT License

Copyright (c) 2025 Matthew Abbott

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions: 

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MLP</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            margin: 0; padding: 1.5rem;
            background: #f8fafc;
            color: #1e293b;
        }
        h1 { color: #0f172a; margin-bottom: 0.5rem; }
        h2 { color: #334155; font-size: 1.1rem; margin: 0 0 0.75rem 0; }
        .container { max-width: 1400px; margin: 0 auto; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
        .panel { 
            background: white; 
            border-radius: 12px; 
            padding: 1.25rem; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .section { margin-bottom: 1.25rem; }
        .section:last-child { margin-bottom: 0; }
        
        label { display: inline-block; margin: 0.25rem 0.5rem 0.25rem 0; font-size: 0.9rem; }
        input[type="number"], input[type="text"], select { 
            padding: 0.4rem 0.5rem; 
            border: 1px solid #cbd5e1; 
            border-radius: 6px;
            font-size: 0.9rem;
        }
        input[type="number"] { width: 4.5rem; }
        input[type="text"].nodevals { width: 5rem; }
        input.error { border-color: #ef4444; background: #fef2f2; }
        textarea { 
            width: 100%; height: 6rem; 
            padding: 0.5rem; 
            border: 1px solid #cbd5e1; 
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.85rem;
            resize: vertical;
        }
        textarea.error { border-color: #ef4444; background: #fef2f2; }
        
        input[type="checkbox"] { 
            width: 1rem; height: 1rem; 
            vertical-align: middle; 
            margin-right: 0.25rem;
        }
        
        button { 
            padding: 8px 16px; 
            background: #5a5a5a; 
            color: white; 
            border: none; 
            border-radius: 0; 
            cursor: pointer;
            font-size: 0.9rem;
            margin: 0.25rem 0.25rem 0.25rem 0;
            transition: background 0.2s;
        }
        button:hover { background: #4a4a4a; }
        button:active { background: #3a3a3a; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.secondary { background: #64748b; }
        button.secondary:hover { background: #475569; }
        button.danger { background: #ef4444; }
        button.danger:hover { background: #dc2626; }
        
        .error-msg { 
            color: #dc2626; 
            background: #fef2f2; 
            padding: 0.5rem 0.75rem; 
            border-radius: 6px; 
            margin: 0.5rem 0;
            font-size: 0.85rem;
        }
        .success-msg {
            color: #16a34a;
            background: #f0fdf4;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            font-size: 0.85rem;
        }
        
        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .metric {
            background: #f1f5f9;
            padding: 0.75rem;
            border-radius: 8px;
            text-align: center;
        }
        .metric-label { font-size: 0.75rem; color: #64748b; text-transform: uppercase; }
        .metric-value { font-size: 1.25rem; font-weight: 600; color: #0f172a; }
        
        #lossChart { 
            width: 100%; 
            height: 200px; 
            background: #f8fafc; 
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .output-panel {
            background: #f1f5f9;
            padding: 1rem;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.85rem;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .slider-container { display: flex; align-items: center; gap: 0.5rem; margin: 0.25rem 0; }
        .slider-container input[type="range"] { flex: 1; max-width: 150px; }
        .slider-value { min-width: 3rem; font-size: 0.85rem; color: #64748b; }
        
        .input-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); 
            gap: 0.5rem;
            max-height: 150px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }
        .input-row { 
            display: flex; 
            align-items: center; 
            gap: 0.25rem;
            background: #f8fafc;
            padding: 0.4rem;
            border-radius: 6px;
        }
        .input-label { min-width: 3rem; font-size: 0.8rem; color: #64748b; }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
            margin: 0.5rem 0;
        }
        .progress-fill {
            height: 100%;
            background: #3b82f6;
            transition: width 0.1s;
        }
        
        .legend { font-size: 0.75rem; color: #64748b; margin-top: 0.5rem; }
        
        @media (max-width: 900px) {
            .grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MLP</h1>
        
        <!-- Network Architecture Visualization -->
        <div class="panel section">
            <h2>Network Architecture</h2>
            <div id="networkVisualization"></div>
        </div>
        
        <div class="grid">
            <!-- Left Column: Configuration & Inputs -->
            <div>
                <!-- Network Configuration -->
                <div class="panel section">
                    <h2>Network Configuration</h2>
                    <div style="display:flex; flex-wrap:wrap; gap:0.5rem 1rem;">
                        <label>Input Size: <input type="number" id="inputSize" value="2" min="1" max="100"></label>
                        <label>Hidden Sizes (comma-separated): <input type="text" id="hiddenSizes" value="4,3" placeholder="e.g., 4 or 4,3,2 or 8,8,8"></label>
                        <label>Output Size: <input type="number" id="outputSize" value="1" min="1" max="32"></label>
                    </div>
                    <p style="font-size: 0.8rem; color: #64748b; margin: 0.5rem 0 0 0;">Multiple hidden layers: enter comma-separated values (e.g., <code>4,3,2</code> = 3 hidden layers)</p>
                    <div style="margin-top:0.75rem;">
                        <button onclick="createNetwork()">Create Network</button>
                        <button class="secondary" onclick="randomizeInputs()">Random Inputs</button>
                        <button class="danger" onclick="resetModel()">Reset</button>
                    </div>
                </div>
                
                <!-- Hyperparameters -->
                <div class="panel section">
                    <h2>Hyperparameters</h2>
                    <div class="slider-container">
                        <label>Learning Rate:</label>
                        <input type="range" id="learningRate" min="-4" max="-1" step="0.1" value="-1" oninput="updateSliderDisplay()">
                        <span class="slider-value" id="lrDisplay">0.1</span>
                    </div>
                    <div class="slider-container">
                        <label>Iterations:</label>
                        <input type="range" id="trainIters" min="10" max="1000" step="10" value="100" oninput="updateSliderDisplay()">
                        <span class="slider-value" id="iterDisplay">100</span>
                    </div>
                    <div style="margin-top:0.5rem;">
                        <label>Hidden Activation: 
                            <select id="hiddenActivation">
                                <option value="sigmoid">Sigmoid</option>
                                <option value="tanh">Tanh</option>
                                <option value="relu">ReLU</option>
                            </select>
                        </label>
                        <label>Output Activation: 
                            <select id="outputActivation">
                                <option value="sigmoid">Sigmoid</option>
                                <option value="tanh">Tanh</option>
                                <option value="relu">ReLU</option>
                            </select>
                        </label>
                    </div>
                    <div style="margin-top:0.5rem;">
                        <label>Optimizer:
                            <select id="optimizer">
                                <option value="sgd">SGD</option>
                                <option value="adam">Adam</option>
                                <option value="rmsprop">RMSProp</option>
                            </select>
                        </label>
                    </div>
                </div>

                <!-- Regularization -->
                <div class="panel section">
                    <h2>Regularization</h2>
                    <div class="slider-container">
                        <label>Dropout Rate (0-1):</label>
                        <input type="range" id="dropoutRate" min="0" max="0.9" step="0.1" value="0" oninput="updateSliderDisplay()">
                        <span class="slider-value" id="dropoutDisplay">0.0</span>
                    </div>
                    <div class="slider-container">
                        <label>L2 Lambda (0-0.1):</label>
                        <input type="range" id="l2Lambda" min="0" max="0.1" step="0.001" value="0" oninput="updateSliderDisplay()">
                        <span class="slider-value" id="l2Display">0.0</span>
                    </div>
                </div>
                
                <!-- Data Loading -->
                <div class="panel section">
                    <h2>Load Training Data</h2>
                    <input type="file" id="csvFile" accept=".csv">
                    <button onclick="loadCSV()">Load CSV File</button>
                    <span id="dataStatus" style="margin-left:1rem;"></span>
                    <div style="margin-top:0.5rem;">
                        <label>Or paste CSV data:</label>
                        <textarea id="csvPaste" rows="4" cols="40"></textarea>
                        <button onclick="loadCSVText()" style="margin-top:0.5rem;">Load Pasted CSV</button>
                    </div>
                    <div style="margin-top:0.5rem;">
                        <label><input type="checkbox" id="normalizeData" checked> Normalize input features to [0,1]</label>
                    </div>
                </div>

                <!-- Input Features -->
                <div class="panel section">
                    <h2>Input Features</h2>
                    <div id="inputFields" class="input-grid"></div>
                    <div id="inputError"></div>
                </div>
            </div>
            
            <!-- Right Column: Output & Visualization -->
            <div>
                <!-- Training Configuration -->
                <div class="panel section">
                    <h2>Training Configuration</h2>
                    <div style="display:flex; flex-wrap:wrap; gap:1rem;">
                        <div>
                            <label>Batch Size:
                                <select id="batchSize">
                                    <option value="1">1 (Online)</option>
                                    <option value="32" selected>32</option>
                                    <option value="64">64</option>
                                    <option value="128">128</option>
                                    <option value="all">Full Batch</option>
                                </select>
                            </label>
                        </div>
                    </div>
                    <div style="margin-top:0.75rem;">
                        <label><input type="checkbox" id="enableLRDecay"> Enable Learning Rate Decay</label>
                        <span style="margin-left:1rem;">Rate: <input type="number" id="lrDecayRate" value="0.95" step="0.01" min="0.5" max="1" style="width:60px"></span>
                        <span style="margin-left:0.5rem;">per <input type="number" id="lrDecayEpochs" value="10" step="1" min="1" style="width:50px"> epochs</span>
                    </div>
                    <div style="margin-top:0.5rem;">
                        <label><input type="checkbox" id="enableEarlyStopping"> Enable Early Stopping after</label>
                        <span style="margin-left:0.5rem;"><input type="number" id="earlyStoppingPatience" value="10" step="1" min="1" style="width:50px"> epochs without improvement</span>
                    </div>
                </div>

                <!-- Generate Test Data -->
                <div class="panel section">
                    <h2>Generate Test Data</h2>
                    <label>Samples per Class: <input type="number" id="samplesPerClass" value="100" min="10"></label>
                    <button onclick="generateTestData()" style="margin-left:0.5rem;">Generate Data</button>
                    <span id="generateStatus" style="margin-left:1rem;"></span>
                </div>

                <!-- Training & Prediction -->
                <div class="panel section">
                    <h2>Training & Prediction</h2>
                    <div>
                        <label>Target Output: <input type="text" id="targetOutput" placeholder="e.g., 0.8" value="0.5"></label>
                    </div>
                    <div style="margin-top:0.5rem;">
                        <button id="trainBtn" onclick="trainModel()" disabled>Train</button>
                        <button id="trainProgressBtn" onclick="trainNetworkWithProgress()" disabled>Train with Progress</button>
                        <button id="predictBtn" onclick="predictModel()" disabled>Predict</button>
                    </div>
                    <div style="margin-top:0.5rem;">
                        <button class="secondary" onclick="saveModelDialog()">Save Model</button>
                        <button class="secondary" onclick="loadModelDialog()">Load Model</button>
                    </div>
                    <div id="trainStatus" style="margin-top:0.5rem;"></div>
                    <div id="trainingProgress"></div>
                    <div id="output" class="output-panel" style="margin-top:1rem;"></div>
                </div>

                <!-- Model Evaluation -->
                <div class="panel section">
                    <h2>Model Evaluation</h2>
                    <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
                        <div>
                            <label>K-Fold (k=<input type="number" id="numFolds" value="5" min="2" max="10" style="width:50px">)</label>
                        </div>
                    </div>
                    <div style="margin-top:0.5rem;">
                        <button onclick="runKFoldValidation()" disabled id="kFoldBtn">Run K-Fold Validation</button>
                        <button onclick="runAllMetrics()" disabled id="metricsBtn">Run All Metrics</button>
                    </div>
                    <div id="evaluationResults" style="margin-top:0.5rem;"></div>
                </div>
                
                <!-- Loss Chart -->
                <div class="panel section">
                    <h2>Loss History</h2>
                    <canvas id="lossChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
// ==================== NEURON & LAYER ====================

class Neuron {
    constructor(numInputs) {
        this.weights = Array.from({length: numInputs}, () => Math.random() * 2 - 1);
        this.bias = Math.random() * 2 - 1;
        this.output = 0;
        this.error = 0;
        this.m = Array(numInputs).fill(0);
        this.v = Array(numInputs).fill(0);
        this.mBias = 0;
        this.vBias = 0;
    }
}

class DenseLayer {
    constructor(numNeurons, numInputs, activation = 'sigmoid') {
        this.neurons = Array.from({length: numNeurons}, () => new Neuron(numInputs));
        this.activation = activation;
        this.lastInput = [];
    }

    forward(input) {
        this.lastInput = [...input];
        return this.neurons.map(neuron => {
            const preAct = neuron.weights.reduce((s, w, i) => s + w * input[i], neuron.bias);
            neuron.output = this.applyActivation(preAct);
            return neuron.output;
        });
    }

    applyActivation(x) {
        switch(this.activation) {
            case 'sigmoid': return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
            case 'tanh': return Math.tanh(x);
            case 'relu': return Math.max(0, x);
            default: return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
        }
    }

    activationDerivative(output, preAct) {
        switch(this.activation) {
            case 'sigmoid': return output * (1 - output);
            case 'tanh': return 1 - output * output;
            case 'relu': return preAct > 0 ? 1 : 0;
            default: return output * (1 - output);
        }
    }

    setWeights(data) {
        if (data.weights && data.biases) {
            for (let i = 0; i < this.neurons.length; i++) {
                this.neurons[i].weights = [...data.weights[i]];
                this.neurons[i].bias = data.biases[i] || 0;
            }
        }
    }

    getWeights() {
        return {
            weights: this.neurons.map(n => [...n.weights]),
            biases: this.neurons.map(n => n.bias)
        };
    }
}

// ==================== MLP ====================

class MultiLayerPerceptron {
    constructor(inputSize, hiddenSizes, outputSize, hiddenAct = 'sigmoid', outputAct = 'sigmoid') {
        this.inputSize = inputSize;
        this.hiddenSizes = hiddenSizes;
        this.outputSize = outputSize;
        this.hiddenActivation = hiddenAct;
        this.outputActivation = outputAct;
        
        this.layers = [];
        
        // Build hidden layers
        let prevSize = inputSize;
        for (let size of hiddenSizes) {
            this.layers.push(new DenseLayer(size, prevSize, hiddenAct));
            prevSize = size;
        }
        
        // Output layer
        this.layers.push(new DenseLayer(outputSize, prevSize, outputAct));
        
        this.learningRate = 0.1;
        this.lossHistory = [];
    }

    forward(input) {
        let current = input;
        for (let layer of this.layers) {
            current = layer.forward(current);
        }
        return current;
    }

    predict(input) {
        return this.forward(input);
    }

    backward(target) {
        let errors = [];
        const outputLayer = this.layers[this.layers.length - 1];
        
        // Output layer error
        for (let i = 0; i < outputLayer.neurons.length; i++) {
            const neuron = outputLayer.neurons[i];
            const delta = target[i] - neuron.output;
            errors[i] = delta * neuron.outputActivateDerivative ? 
                delta * (neuron.output * (1 - neuron.output)) : 
                delta * neuron.output * (1 - neuron.output);
            neuron.error = errors[i];
        }
        
        // Backprop through hidden layers
        for (let l = this.layers.length - 2; l >= 0; l--) {
            const layer = this.layers[l];
            const nextLayer = this.layers[l + 1];
            const nextErrors = [];
            
            for (let i = 0; i < layer.neurons.length; i++) {
                let error = 0;
                for (let j = 0; j < nextLayer.neurons.length; j++) {
                    error += nextLayer.neurons[j].weights[i] * nextLayer.neurons[j].error;
                }
                const neuron = layer.neurons[i];
                nextErrors[i] = error * (neuron.output * (1 - neuron.output));
                neuron.error = nextErrors[i];
            }
            errors = nextErrors;
        }
    }

    updateWeights() {
        for (let layer of this.layers) {
            for (let neuron of layer.neurons) {
                for (let j = 0; j < neuron.weights.length; j++) {
                    neuron.weights[j] += this.learningRate * neuron.error * layer.lastInput[j];
                }
                neuron.bias += this.learningRate * neuron.error;
            }
        }
    }

    train(input, target) {
        this.forward(input);
        this.backward(target);
        this.updateWeights();
        return this.computeLoss(this.layers[this.layers.length - 1].neurons.map(n => n.output), target);
    }

    computeLoss(predicted, target) {
        let loss = 0;
        for (let i = 0; i < predicted.length; i++) {
            loss += Math.pow(target[i] - predicted[i], 2);
        }
        return loss / predicted.length;
    }

    getWeights() {
        return {
            inputSize: this.inputSize,
            hiddenSizes: this.hiddenSizes,
            outputSize: this.outputSize,
            hiddenActivation: this.hiddenActivation,
            outputActivation: this.outputActivation,
            learningRate: this.learningRate,
            layers: this.layers.map(layer => layer.getWeights()),
            lossHistory: this.lossHistory
        };
    }

    setWeights(data) {
        this.inputSize = data.inputSize;
        this.hiddenSizes = data.hiddenSizes;
        this.outputSize = data.outputSize;
        this.hiddenActivation = data.hiddenActivation;
        this.outputActivation = data.outputActivation;
        this.learningRate = data.learningRate || 0.1;
        this.lossHistory = data.lossHistory || [];
        
        // Handle JavaScript format (data.layers)
        if (data.layers && data.layers.length > 0) {
            for (let i = 0; i < this.layers.length; i++) {
                this.layers[i].setWeights(data.layers[i]);
            }
        }
        // Handle Pascal JSON format (data.hidden_layers and data.output_layer)
        else if (data.hidden_layers && data.output_layer) {
            // Load hidden layers
            for (let i = 0; i < data.hidden_layers.length; i++) {
                const layer = data.hidden_layers[i];
                if (layer.weights && layer.biases) {
                    for (let j = 0; j < this.layers[i].neurons.length; j++) {
                        this.layers[i].neurons[j].weights = layer.weights[j];
                        this.layers[i].neurons[j].bias = layer.biases[j];
                    }
                }
            }
            // Load output layer
            const outputLayer = data.output_layer;
            if (outputLayer.weights && outputLayer.biases) {
                const lastLayerIdx = this.layers.length - 1;
                for (let j = 0; j < this.layers[lastLayerIdx].neurons.length; j++) {
                    this.layers[lastLayerIdx].neurons[j].weights = outputLayer.weights[j];
                    this.layers[lastLayerIdx].neurons[j].bias = outputLayer.biases[j];
                }
            }
        }
    }
}

// ==================== ML EVALUATION & METRICS ====================

class MLEvaluation {
    static trainWithBatches(mlp, data, epochs, batchSize, progressCallback = null) {
        if (data.length === 0) return;
        
        let actualBatchSize = batchSize === 'all' ? data.length : parseInt(batchSize);
        let validationLosses = [];
        let bestLoss = Infinity;
        let patienceCounter = 0;
        const patience = parseInt(document.getElementById('earlyStoppingPatience').value);
        const enableEarlyStopping = document.getElementById('enableEarlyStopping').checked;
        const enableLRDecay = document.getElementById('enableLRDecay').checked;
        const lrDecayRate = parseFloat(document.getElementById('lrDecayRate').value);
        const lrDecayEpochs = parseInt(document.getElementById('lrDecayEpochs').value);
        
        let originalLR = mlp.learningRate;
        
        for (let epoch = 0; epoch < epochs; epoch++) {
            let totalLoss = 0;
            
            for (let i = 0; i < data.length; i += actualBatchSize) {
                const batchEnd = Math.min(i + actualBatchSize, data.length);
                
                for (let j = i; j < batchEnd; j++) {
                    const sample = data[j];
                    const inputs = sample.slice(0, mlp.inputSize);
                    const target = sample.slice(mlp.inputSize);
                    const loss = mlp.train(inputs, target);
                    totalLoss += loss;
                }
            }
            
            const avgLoss = totalLoss / data.length;
            validationLosses.push(avgLoss);
            
            if (enableLRDecay && (epoch + 1) % lrDecayEpochs === 0) {
                mlp.learningRate *= lrDecayRate;
            }
            
            if (enableEarlyStopping) {
                if (avgLoss < bestLoss) {
                    bestLoss = avgLoss;
                    patienceCounter = 0;
                } else {
                    patienceCounter++;
                }
            }
            
            if (progressCallback) {
                progressCallback(epoch + 1, epochs, validationLosses, patienceCounter >= patience);
            }
            
            if (enableEarlyStopping && patienceCounter >= patience) {
                if (progressCallback) progressCallback(epoch + 1, epochs, validationLosses, true);
                break;
            }
        }
        
        mlp.learningRate = originalLR;
    }
    
    static precisionScore(data, mlp, classIndex) {
        if (data.length === 0) return 0;
        
        let truePositives = 0;
        let falsePositives = 0;
        
        for (let sample of data) {
            const inputs = sample.slice(0, mlp.inputSize);
            const target = sample.slice(mlp.inputSize);
            const output = mlp.predict(inputs);
            const predictedClass = output.indexOf(Math.max(...output));
            const trueClass = target.indexOf(Math.max(...target));
            
            if (predictedClass === classIndex) {
                if (trueClass === classIndex) truePositives++;
                else falsePositives++;
            }
        }
        
        return truePositives + falsePositives === 0 ? 0 : truePositives / (truePositives + falsePositives);
    }
    
    static recallScore(data, mlp, classIndex) {
        if (data.length === 0) return 0;
        
        let truePositives = 0;
        let falseNegatives = 0;
        
        for (let sample of data) {
            const inputs = sample.slice(0, mlp.inputSize);
            const target = sample.slice(mlp.inputSize);
            const output = mlp.predict(inputs);
            const predictedClass = output.indexOf(Math.max(...output));
            const trueClass = target.indexOf(Math.max(...target));
            
            if (trueClass === classIndex) {
                if (predictedClass === classIndex) truePositives++;
                else falseNegatives++;
            }
        }
        
        return truePositives + falseNegatives === 0 ? 0 : truePositives / (truePositives + falseNegatives);
    }
    
    static f1Score(precision, recall) {
        if (precision + recall === 0) return 0;
        return 2 * (precision * recall) / (precision + recall);
    }
    
    static accuracy(data, mlp) {
        if (data.length === 0) return 0;
        
        let correct = 0;
        for (let sample of data) {
            const inputs = sample.slice(0, mlp.inputSize);
            const target = sample.slice(mlp.inputSize);
            const output = mlp.predict(inputs);
            const predictedClass = output.indexOf(Math.max(...output));
            const trueClass = target.indexOf(Math.max(...target));
            if (predictedClass === trueClass) correct++;
        }
        
        return correct / data.length;
    }
    
    static kFoldCrossValidation(data, k, mlpTemplate, epochs) {
        const foldSize = Math.floor(data.length / k);
        let totalAccuracy = 0;
        
        for (let fold = 0; fold < k; fold++) {
            const testStart = fold * foldSize;
            const testEnd = fold === k - 1 ? data.length : (fold + 1) * foldSize;
            
            const testData = data.slice(testStart, testEnd);
            const trainData = data.slice(0, testStart).concat(data.slice(testEnd));
            
            const mlp = new MultiLayerPerceptron(
                mlpTemplate.inputSize,
                mlpTemplate.hiddenSizes,
                mlpTemplate.outputSize,
                mlpTemplate.hiddenActivation,
                mlpTemplate.outputActivation
            );
            mlp.learningRate = mlpTemplate.learningRate;
            
            this.trainWithBatches(mlp, trainData, epochs, document.getElementById('batchSize').value);
            
            const foldAccuracy = this.accuracy(testData, mlp);
            totalAccuracy += foldAccuracy;
        }
        
        return totalAccuracy / k;
    }
}

// ==================== DATA HANDLING ====================

let trainingData = [];
let normalizationParams = null;

function parseCSV(text) {
    const lines = text.trim().split('\n');
    const data = [];
    
    for (let line of lines) {
        if (!line.trim()) continue;
        const values = line.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
        if (values.length > 0) {
            data.push(values);
        }
    }
    
    return data;
}

function normalizeData(data) {
    if (data.length === 0) return { data: [], mins: [], maxs: [] };
    
    const mins = Array(data[0].length).fill(Infinity);
    const maxs = Array(data[0].length).fill(-Infinity);
    
    for (let sample of data) {
        for (let i = 0; i < sample.length; i++) {
            mins[i] = Math.min(mins[i], sample[i]);
            maxs[i] = Math.max(maxs[i], sample[i]);
        }
    }
    
    const normalized = data.map(sample => 
        sample.map((val, i) => {
            const range = maxs[i] - mins[i];
            if (range === 0) return 0.5;
            return (val - mins[i]) / range;
        })
    );
    
    return { data: normalized, mins: mins, maxs: maxs };
}

function loadCSV() {
    const fileInput = document.getElementById('csvFile');
    if (fileInput.files.length === 0) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
        trainingData = parseCSV(e.target.result);
        
        if (document.getElementById('normalizeData').checked && trainingData.length > 0) {
            const result = normalizeData(trainingData);
            trainingData = result.data;
            normalizationParams = { mins: result.mins, maxs: result.maxs };
            document.getElementById('dataStatus').innerText = `Loaded and normalized ${trainingData.length} samples`;
        } else {
            document.getElementById('dataStatus').innerText = `Loaded ${trainingData.length} samples`;
        }
    };
    reader.readAsText(fileInput.files[0]);
}

function loadCSVText() {
    const text = document.getElementById('csvPaste').value;
    trainingData = parseCSV(text);
    
    if (document.getElementById('normalizeData').checked && trainingData.length > 0) {
        const result = normalizeData(trainingData);
        trainingData = result.data;
        normalizationParams = { mins: result.mins, maxs: result.maxs };
        document.getElementById('dataStatus').innerText = `Loaded and normalized ${trainingData.length} samples`;
    } else {
        document.getElementById('dataStatus').innerText = `Loaded ${trainingData.length} samples`;
    }
}

// ==================== GLOBALS ====================

let currentMLP = null;
let lossHistory = [];

// ==================== UI UPDATES ====================

function updateSliderDisplay() {
    const lrSlider = document.getElementById('learningRate');
    const lrValue = Math.pow(10, parseFloat(lrSlider.value));
    document.getElementById('lrDisplay').textContent = lrValue.toFixed(4);
    if (currentMLP) currentMLP.learningRate = lrValue;

    const iterSlider = document.getElementById('trainIters');
    document.getElementById('iterDisplay').textContent = iterSlider.value;

    const dropoutSlider = document.getElementById('dropoutRate');
    document.getElementById('dropoutDisplay').textContent = parseFloat(dropoutSlider.value).toFixed(1);

    const l2Slider = document.getElementById('l2Lambda');
    document.getElementById('l2Display').textContent = parseFloat(l2Slider.value).toFixed(4);
}

function buildInputFields() {
    const container = document.getElementById('inputFields');
    container.innerHTML = '';
    
    if (!currentMLP) return;
    
    for (let i = 0; i < currentMLP.inputSize; i++) {
        const row = document.createElement('div');
        row.className = 'input-row';
        row.innerHTML = `
            <span class="input-label">In ${i}:</span>
            <input type="number" id="input${i}" value="0.5" min="0" max="1" step="0.01">
        `;
        container.appendChild(row);
    }
}

function createNetwork() {
    const inputSize = parseInt(document.getElementById('inputSize').value);
    const hiddenText = document.getElementById('hiddenSizes').value;
    const hiddenSizes = hiddenText.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
    const outputSize = parseInt(document.getElementById('outputSize').value);
    
    if (hiddenSizes.length === 0) {
        alert('Please specify at least one hidden layer size');
        return;
    }
    
    const hiddenAct = document.getElementById('hiddenActivation').value;
    const outputAct = document.getElementById('outputActivation').value;
    
    currentMLP = new MultiLayerPerceptron(inputSize, hiddenSizes, outputSize, hiddenAct, outputAct);
    currentMLP.learningRate = Math.pow(10, parseFloat(document.getElementById('learningRate').value));
    
    buildInputFields();
    lossHistory = [];
    updateLossChart();
    visualizeMLPArchitecture(currentMLP);
    document.getElementById('output').innerHTML = '<div class="success-msg">Network created successfully</div>';
    document.getElementById('trainBtn').disabled = false;
    document.getElementById('predictBtn').disabled = false;
}

function randomizeInputs() {
    for (let i = 0; i < (currentMLP ? currentMLP.inputSize : 0); i++) {
        const elem = document.getElementById(`input${i}`);
        if (elem) elem.value = Math.random().toFixed(2);
    }
}

function trainModel() {
    if (!currentMLP) return;
    
    const inputs = Array.from({length: currentMLP.inputSize}, (_, i) => 
        parseFloat(document.getElementById(`input${i}`).value) || 0
    );
    
    const targetText = document.getElementById('targetOutput').value;
    const target = targetText.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
    
    if (target.length === 0) {
        alert('Please specify target output');
        return;
    }
    
    const iterations = parseInt(document.getElementById('trainIters').value);
    
    lossHistory = [];
    for (let iter = 0; iter < iterations; iter++) {
        const loss = currentMLP.train(inputs, target);
        lossHistory.push(loss);
    }
    
    updateLossChart();
    const finalOutput = currentMLP.predict(inputs);
    
    let msg = `<div class="success-msg">Training completed (${iterations} iterations)<br>`;
    msg += `Final loss: ${lossHistory[lossHistory.length - 1].toFixed(6)}<br>`;
    msg += `Output: ${finalOutput.map(v => v.toFixed(6)).join(', ')}</div>`;
    document.getElementById('output').innerHTML = msg;
}

function predictModel() {
    if (!currentMLP) return;
    
    let inputs = Array.from({length: currentMLP.inputSize}, (_, i) => 
        parseFloat(document.getElementById(`input${i}`).value) || 0
    );
    
    // Apply normalization if available
    if (normalizationParams) {
        inputs = inputs.map((val, idx) => {
            const range = normalizationParams.maxs[idx] - normalizationParams.mins[idx];
            if (range === 0) return 0.5;
            return (val - normalizationParams.mins[idx]) / range;
        });
    }
    
    const output = currentMLP.predict(inputs);
    
    let msg = '<div class="success-msg">Prediction:<br>';
    for (let i = 0; i < output.length; i++) {
        msg += `Output ${i}: ${output[i].toFixed(6)}<br>`;
    }
    msg += '</div>';
    document.getElementById('output').innerHTML = msg;
}

function updateLossChart() {
    const canvas = document.getElementById('lossChart');
    const ctx = canvas.getContext('2d');
    
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = 200;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (lossHistory.length === 0) return;
    
    const padding = 40;
    const width = canvas.width - 2 * padding;
    const height = canvas.height - 2 * padding;
    
    const maxLoss = Math.max(...lossHistory, 0.001);
    
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    for (let i = 0; i < lossHistory.length; i++) {
        const x = padding + (i / (lossHistory.length - 1 || 1)) * width;
        const y = canvas.height - padding - (lossHistory[i] / maxLoss) * height;
        
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();
    
    // Axes
    ctx.strokeStyle = '#1e293b';
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, canvas.height - padding);
    ctx.lineTo(canvas.width - padding, canvas.height - padding);
    ctx.stroke();
    
    // Labels
    ctx.fillStyle = '#1e293b';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(maxLoss.toFixed(3), padding - 5, padding + 5);
    ctx.textAlign = 'center';
    ctx.fillText(lossHistory.length - 1, canvas.width - padding, canvas.height - 20);
}

function saveModelDialog() {
    if (!currentMLP) {
        alert('No model to save');
        return;
    }
    
    const data = JSON.stringify(currentMLP.getWeights(), null, 2);
    const blob = new Blob([data], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'mlp_model.json';
    a.click();
    URL.revokeObjectURL(url);
}

function loadModelDialog() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const data = JSON.parse(event.target.result);
                
                // Handle both camelCase (JavaScript) and snake_case (Pascal) formats
                const inputSize = data.inputSize || data.input_size;
                const hiddenSizes = data.hiddenSizes || data.hidden_sizes;
                const outputSize = data.outputSize || data.output_size;
                const hiddenActivation = data.hiddenActivation || data.hidden_activation || 'sigmoid';
                const outputActivation = data.outputActivation || data.output_activation || 'sigmoid';
                
                currentMLP = new MultiLayerPerceptron(inputSize, hiddenSizes, outputSize, hiddenActivation, outputActivation);
                currentMLP.setWeights({
                    inputSize: inputSize,
                    hiddenSizes: hiddenSizes,
                    outputSize: outputSize,
                    hiddenActivation: hiddenActivation,
                    outputActivation: outputActivation,
                    learningRate: data.learningRate || data.learning_rate || 0.1,
                    lossHistory: data.lossHistory || []
                });
                
                document.getElementById('inputSize').value = inputSize;
                document.getElementById('hiddenSizes').value = hiddenSizes.join(',');
                document.getElementById('outputSize').value = outputSize;
                document.getElementById('hiddenActivation').value = hiddenActivation;
                document.getElementById('outputActivation').value = outputActivation;
                
                buildInputFields();
                lossHistory = data.lossHistory || [];
                updateLossChart();
                visualizeMLPArchitecture(currentMLP);
                
                document.getElementById('output').innerHTML = '<div class="success-msg">Model loaded successfully</div>';
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('predictBtn').disabled = false;
            } catch (err) {
                alert('Failed to load model: ' + err.message);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

function resetModel() {
    currentMLP = null;
    lossHistory = [];
    document.getElementById('output').innerHTML = '';
    document.getElementById('inputFields').innerHTML = '';
    document.getElementById('trainBtn').disabled = true;
    document.getElementById('predictBtn').disabled = true;
    updateLossChart();
}

// ==================== NETWORK VISUALIZATION ====================

function visualizeMLPArchitecture(mlp) {
    if (!mlp) return;
    
    const container = document.getElementById('networkVisualization');
    if (!container) return;
    
    const spacing = 85;
    const padding = 20;
    const legendSpace = 80;
    const totalLayers = 2 + mlp.hiddenSizes.length;
    
    const totalWidth = totalLayers * spacing + padding * 2 + legendSpace;
    const totalHeight = 200;
    
    const svgContainer = document.createElement('div');
    svgContainer.setAttribute('style', 'overflow-x: auto; overflow-y: hidden; border: 1px solid #ccc; background: #fafafa; border-radius: 4px; margin: 1rem 0; height: 220px;');
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', totalWidth);
    svg.setAttribute('height', totalHeight);
    svg.setAttribute('style', 'display: block;');
    
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.innerHTML = `
        <linearGradient id="inputGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#e8f5e9;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#c8e6c9;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="hiddenGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#ea4335;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#c5221f;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="outGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#fbbc04;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#f57d00;stop-opacity:1" />
        </linearGradient>
    `;
    svg.appendChild(defs);
    
    let xPos = padding + legendSpace;
    
    // Draw input layer
    drawMLPInputLayer(svg, xPos, totalHeight / 2, mlp.inputSize);
    xPos += spacing;
    
    // Draw hidden layers
    for (let i = 0; i < mlp.hiddenSizes.length; i++) {
        drawMLPHiddenLayer(svg, xPos, totalHeight / 2, mlp.hiddenSizes[i], i + 1);
        xPos += spacing;
    }
    
    // Draw output layer
    drawMLPOutputLayer(svg, xPos, totalHeight / 2, mlp.outputSize);
    
    // Draw legend
    drawMLPLegend(svg, padding + 5, totalHeight / 2 - 30);
    
    svgContainer.innerHTML = '';
    svgContainer.appendChild(svg);
    
    container.innerHTML = '';
    container.appendChild(svgContainer);
}

function drawMLPInputLayer(svg, x, cy, neurons) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', x - 25);
    box.setAttribute('y', cy - 35);
    box.setAttribute('width', 50);
    box.setAttribute('height', 70);
    box.setAttribute('fill', '#e8f5e9');
    box.setAttribute('stroke', '#2e7d32');
    box.setAttribute('stroke-width', 1.5);
    box.setAttribute('rx', 3);
    g.appendChild(box);
    
    const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text1.setAttribute('x', x);
    text1.setAttribute('y', cy - 18);
    text1.setAttribute('text-anchor', 'middle');
    text1.setAttribute('font-size', '10');
    text1.setAttribute('font-weight', 'bold');
    text1.setAttribute('fill', '#1b5e20');
    text1.textContent = 'Input';
    g.appendChild(text1);
    
    const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text2.setAttribute('x', x);
    text2.setAttribute('y', cy + 2);
    text2.setAttribute('text-anchor', 'middle');
    text2.setAttribute('font-size', '9');
    text2.setAttribute('fill', '#1b5e20');
    text2.textContent = `${neurons}`;
    g.appendChild(text2);
    
    svg.appendChild(g);
}

function drawMLPHiddenLayer(svg, x, cy, neurons, layerNum) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', x - 25);
    box.setAttribute('y', cy - 35);
    box.setAttribute('width', 50);
    box.setAttribute('height', 70);
    box.setAttribute('fill', 'url(#hiddenGrad)');
    box.setAttribute('stroke', '#c5221f');
    box.setAttribute('stroke-width', 1.5);
    box.setAttribute('rx', 3);
    g.appendChild(box);
    
    const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text1.setAttribute('x', x);
    text1.setAttribute('y', cy - 18);
    text1.setAttribute('text-anchor', 'middle');
    text1.setAttribute('font-size', '9');
    text1.setAttribute('font-weight', 'bold');
    text1.setAttribute('fill', 'white');
    text1.textContent = `H${layerNum}`;
    g.appendChild(text1);
    
    const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text2.setAttribute('x', x);
    text2.setAttribute('y', cy + 8);
    text2.setAttribute('text-anchor', 'middle');
    text2.setAttribute('font-size', '8');
    text2.setAttribute('fill', 'white');
    text2.textContent = `${neurons}`;
    g.appendChild(text2);
    
    svg.appendChild(g);
}

function drawMLPOutputLayer(svg, x, cy, neurons) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', x - 28);
    box.setAttribute('y', cy - 35);
    box.setAttribute('width', 56);
    box.setAttribute('height', 70);
    box.setAttribute('fill', 'url(#outGrad)');
    box.setAttribute('stroke', '#f57d00');
    box.setAttribute('stroke-width', 1.5);
    box.setAttribute('rx', 3);
    g.appendChild(box);
    
    const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text1.setAttribute('x', x);
    text1.setAttribute('y', cy - 18);
    text1.setAttribute('text-anchor', 'middle');
    text1.setAttribute('font-size', '10');
    text1.setAttribute('font-weight', 'bold');
    text1.setAttribute('fill', 'white');
    text1.textContent = 'Output';
    g.appendChild(text1);
    
    const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text2.setAttribute('x', x);
    text2.setAttribute('y', cy + 8);
    text2.setAttribute('text-anchor', 'middle');
    text2.setAttribute('font-size', '8');
    text2.setAttribute('fill', 'white');
    text2.textContent = `${neurons}`;
    g.appendChild(text2);
    
    svg.appendChild(g);
}

function drawMLPLegend(svg, x, y) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    const items = [
        { label: 'Input', color: '#e8f5e9', stroke: '#2e7d32' },
        { label: 'Hidden', color: 'url(#hiddenGrad)', stroke: '#c5221f' },
        { label: 'Output', color: 'url(#outGrad)', stroke: '#f57d00' }
    ];
    
    let yOffset = y;
    items.forEach(item => {
        const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        box.setAttribute('x', x);
        box.setAttribute('y', yOffset);
        box.setAttribute('width', 10);
        box.setAttribute('height', 10);
        box.setAttribute('fill', item.color);
        box.setAttribute('stroke', item.stroke);
        box.setAttribute('stroke-width', 0.5);
        box.setAttribute('rx', 2);
        g.appendChild(box);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', x + 14);
        text.setAttribute('y', yOffset + 8);
        text.setAttribute('font-size', '9');
        text.setAttribute('fill', '#333');
        text.textContent = item.label;
        g.appendChild(text);
        
        yOffset += 13;
    });
    
    svg.appendChild(g);
}

// ==================== INITIALIZATION ====================

buildInputFields();
updateSliderDisplay();
updateLossChart();
    </script>
</body>
</html>

